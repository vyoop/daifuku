---
tags:
  - 2024/dec
  - ibmtranscripts
aliases: 
last edited: mod  2
---
# 12 Courses 
## Course 1 : Intro to Software Engineering
### Module 1 : SLDC - The Software Development Lifecycle
#### Learning Objectives
This module = Overview to the field of Software Engineering.
Lesson 1 =  introduced to the field of software engineering, and learn about the software development lifecycle (SDLC), elements of building high-quality software, and writing requirements. 
Lesson 2 = explore different approaches to building software and different career opportunities related to software development + hear from experienced practitioners in the field and learn how different roles interact and work with each other as a team in order to develop enterprise-level software.

##### Goal
Define software engineering and explain the responsibilities of a software engineer.
- [ ] Discuss key advantages of applying the software development lifecycle (SDLC) when developing enterprise software.
- [ ] Describe each phase of the SDLC
- [ ] Analyze common software engineering processes required for building-high quality software.
- [ ] Explain the requirement gathering process.
- [ ] Differentiate between a User Requirement Specification (URS), a Software Requirement Specification (SRS), and a System Requirement Specification (SysRS) document.
- [ ] Compare and contrast waterfall, V-shape model, and agile methods of software development.
- [ ] Distinguish between functional, non-functional, and regression testing.
- [ ] Identify and describe different types of documentation.
- [ ] Compare and contrast the common roles and responsibilities on a software engineering project.
#### Welcome Intro
##### Course Intro
###### Course is for
learning about software engineering/ finding out more about the software building process/ get more information about software development/  learning about the basics of programming/ software architecture and design/ job prospects are like for a software engineer
######  Salary and Job Stats
According to the most recent US Bureau of Labor Statistics report  about 1,850,000 software engineer type jobs are posted annually in the US alone, and job growth in the industry is projected to increase 22 percent through 2030, At the time of this course publication, the median US software developer specialist salary is 110,140 US dollars annually, and per hour pay is almost $53 US dollars. 
Software engineering jobs are also a great way to start on your path to a high-paying career in information technology.
###### Course Instructors
This course has three instructors: Rav Ahuja, Bethany Hudnutt, and Lin Joyner.
Rav is a Global Program Director at IBM and the architect for several IBM Professional Certificates. 
Bethany is an Instructional Designer at Skill-Up Technologies. And,
Lin is also an Instructional Designer at Skill-Up Technologies.

###### Course Structure
five modules:
1. The Software Development Lifecycle
2. Introduction to Software Development
3. Basics of Programming
4. Software Architecture, Design, and Patterns
5. Job Opportunities and Skillsets in Software Engineering
###### When you complete this course, you’ll be able to
Describe software engineering and approaches to software development.
Identify software development tools and technologies,
Compare different types of programming languages and recognize basic programming constructs,
Outline approaches to application and deployment architectures,
And review the skills required in software
engineering and describe the career options it provides.

##### Meet the Experts
Learn from several experts in various roles, who will provide their insights and perspectives about Software Engineering.

###### Experts, Where they work and What they do.
Kadesha. Developer Advocate at GitHub.
Liseidy Bueno. Software Engineer at Blend, also known as Blend Labs.
Tommy Young. Software Engineer at Google.
	My role is Uber Technical Lead overseeing publisher video ads.
Diane Panagiotopoulos. Research and Development Engineer at Bandwidth.
	I work directly through Bandwidth, not self employed as like a contractor with them.
Zubin Pratap. Software Engineer. Developer Advocate at a Web3 startup
Daniel Rudnitski. Full Stack Software Engineer at IBM.
James Reeve. Full Stack Software Engineer at IBM.
Rupinder. Chief Solutions Architect at Skillup Technologies.
Upkar Lidder. Developer advocate with IBM.
Yann Stoneham. Solution architect at Smartronics.

---
A developer advocate is a software engineer who enables developer to be successful with a product.
	So, essentially, what that means is, for example, at GitHub, I create a lot of content.
	do blog posts, workshops, go to conferences to speak about GitHub, the product,
	showcase developers in the open source community, and to give publicity to the projects that they're working on.

Being an advocate means able to communicate deeply about technical concepts in a way that's digestible for engineers across experience level to understand.

Before I was an advocate, I worked as a software engineer in the finance sector for two years. Spent a majority of my time coding, primarily worked on the front end of the application, using tools such as Git, Docker, GraphQL, React, JavaScript, and the very few times I would go into the back end, we use Node.js on our back end to make changes and updates.

My experience as a software engineer, and also as a technical content creator, paved the way for me to become a developer advocate at GitHub today.

---
I'm a software engineer right now. I'm still pretty Junior. So most of my tasks involve creating new features, fixing bugs, and addressing any customer concerns that we have with that they have with the current software.
I work on a suite of products that are targeted to large content creators, video publishers, customers, such as ESPN,
Disney, etc. We basically have suites of tools to help them monetize their video content, help them distribute it, help them target it appropriately, report on it, troubleshoot it, for across all devices, all surfaces.
So it's kind of the full suite of products, starts with the user interfaces that their sales teams and trafficking teams use to sell the ad space, upload the creatives, the advertisements, and, you know, target them to their audiences and contextually to the content that they're, that they create. We offer reporting on that. So, a lot of its performance and various other analytics, reach analytics, and so forth.

Previously, before this, I was a software engineer at Google. And before that, I was a software engineer at a small startup.
But before that, for about over 15 years, I was a corporate lawyer, and then a business executive for a while and even had my own startup in the middle. So yeah, very diverse background. And I taught myself to code in my very late 30s. When my startup started to fail, and I really needed to keep it going, and my tech co-founder quit.

---
I as a developer advocate, I not only write code, I also produce a lot of educational
content, and material that is useful for people to onboard onto Web3 and other technologies.
And my role is really to help connect the product team with the actual developer ecosystem.
Bring the two together through code, content, education, and community.
​

#### Overview of Software Engineering
##### What is Software Engineering?
Define software engineering, 
list the responsibilities of a software engineer, and 
compare and contrast software developers and software engineers.
###### Definition
Software engineering is the application of scientific principles to the design and creation of software.
The field uses a systematic approach to collect and analyze business requirements in order to design, build, and test software applications to satisfy those business requirements.
###### Birth Timeline of Software Engineering
late 1950s: Computing Began.
	Software Engineering was a relatively undefined discipline, but over time it transformed into a modernized engineering field. 
1960s: Software Crisis Era
	The software engineering field became a discipline and evolved as new technologies were developed and the approach to software development became more scientific.
	Trends in software engineering transformed from ad hoc programming towards more formal and standardized methods.
		Initially, the creation of software lacked a formal development process. 
		As the world widely adopted computers, software became increasingly integral to more aspects of life.
		The inefficiencies in the software development process made it difficult to meet the rapidly increasing demand for computing resources and complex software.
		= became what is known as the “Software Crisis” by mid-1960s
Key Issues of Software Crisis Era
- Software development often ran over budget, behind schedule, and consisted of unmanageable, buggy code. 
- By the time older software solutions came to fruition, newer, better, and faster technologies had already been developed, causing software engineers to have to refactor their code, or completely redesign their system.
- Often software development solutions that worked for small software systems did not scale to large, complex projects.

mid-1980s: end of the Software Crisis era
	The solution to the “Software Crisis” involved transforming unorganized coding efforts into an established engineering discipline.
		Some of these issues still exist today, although to a much lesser extent due to the consistent application of engineering principles to the software development process.
		Computing resources have become more widely available and standardized methodologies for software development allow for large, complex solutions that scale.
also mid 1980s: Rise in the growth of computer-aided software engineering (CASE) → also helped relieve the software crisis.
	CASE tools can be divided into six categories: 
	| Business Analysis and Modeling | Development Tools eg. Debugging Environments | Verification and Validation Tools | | Configuration Management | Metrics and Measurement | Project Management |
###### Software Engineer vs Software Developer
The term “software engineer” is often used interchangeably with software developer but there are subtle differences.
Software engineers are also developers, but 

|                                  | Software Developer                                                                    | Software Engineer                                                                                                                                                                |
| -------------------------------- | ------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| scope                            | usually deemed narrower in scope                                                      | knowledge is usually broader.                                                                                                                                                    |
| approach to software development | may have more creative approaches.                                                    | systematic, big picture approach in their thinking                                                                                                                               |
| Use of Specialized Knowledge     | use their knowledge to write code to implement specific functionality within a system | use that knowledge to build entire systems                                                                                                                                       |
| employment                       |                                                                                       | employed on larger scale projects and they are focused on the broad structure rather than solving an immediate problem.                                                          |
| Main Task                        | implement specific functionalities.                                                   | tasked with designing, building, and maintaining software systems                                                                                                                |
| Responsibilities                 |                                                                                       | Responsibilities include writing and testing code, and consulting with stakeholders such as clients, third party software vendors, security specialists, and other team members. |

###### Modern Dev Process : SDLC
The adoption of a measured, scientific approach to software development influenced the way software is created and designed. 
Modern development process is typically guided by the Software Development Lifecycle (SDLC).

The SDLC identifies the steps needed to develop high-quality software.
##### Insiders' Viewpoint: What is software engineering
I think software engineering is the process of using programming languages and engineering principles to build products. These products could look like web apps, mobile apps, desk top apps, operating systems, or even networking systems. 
It is a skill integral to the success of our modern society as without technology, we couldn't get a lot of things done today. 

Within software engineering. It's a very broad term. Within software engineering, you have roles such as front end, back end, security, mobile, test, full stack, DevOps, cloud data, and machine learning. 
And these are all different types of engineers within software engineering.

Define software engineering as building and improving software from anywhere from design architecture to the user interface to fixing small bugs. 

Software engineering, is a creative process. fundamentally is the practice of designing, envisioning implementing, and then
supporting and maintaining software through the full lifecycle of it. So not just writing code, but, thinking about the software you're building before you even written a line of code, the journey from idea inception to, to actual  implementation and launching upset software and then maintaining it, improving it, supporting it, and potentially
evolving into something else. So it's very much a sort of creative and full, full lifecycle end to end engineering process.

In the United States, at least software engineering, software development, programming
they all have, depending on who you ask, they mean very specific things or very hazy things or very contradictory things.  three different titles kind of all meaning the same thing.

---

Difference between a software engineer and a developer
Consider Engineering broader than then development./ Development is sort of one part of the process. 
So One fundamental difference is software engineering is beyond just writing code, 
A Developer often is handed a task to write a piece of code, create a a module, piece of software etc.
Engineering involves sort of starting, you know, a very long time before you even get to the development process and continues on beyond the time you would actually take your code, deploy it. So kind of goes into the full lifecycle.

There isn't A difference really.  I was trained as a full stack engineer or a full stack developer, but I was hired as a software engineer to work on the front end of the company's application. So I think it's a matter of semantics.
And a lot of it, I think, is a lot of gatekeeping. To keep people who don't know anything about about the industry out. Somebody who has studied CS may argue differently from I do, but as a person with a non traditional path into the world of software engineering, I only see it as like title changes and title differences. And I think it depends on what
company you work in, and what company you work for. Because at the end of the day, we're all using the same tools and technology to get the product shipped to production. 

They are pretty similar roles and used interchangeably a lot.
But I think the main difference is that software engineers are also responsible for the system design and architecture as well as data, how it's received, used, and how it's disseminated.
Whereas software developers, I think, focus more on the building of apps and features.
So, in Canada, being a computer programmer, or a software developer is incredibly different than being a computer engineer or a software engineer, where to be an engineer, it means you've taken specific classes in like codes of ethics. And you're held to the same ethical standards as a civil engineer or a mechanical engineer. 
And so depending on where you are, the name, the titles can mean very different things. And I know for purposes of immigration, the titles also can mean very specific things. And you have to be careful about like, what it is that you put down. But in job descriptions, I kind of see them all used interchangeably, and I tend to just kind of think of them all as the same thing. The, you know, it's much of a more of a longer time horizon, I think, in front in terms of
engineering versus development. I think there's a lot more considerations and hats you need
to put on throughout the software engineering lifecycle versus the kind of more narrowly
scoped development cycle.
​
##### Intro to the SDLC
describe what the software development life cycle is, explain its history, and discuss some key advantages of using it.

###### Definition
Software Development Life Cycle, known as the SDLC,
is a systematic process to develop high-quality software in a predictable timeframe and budget.
The goal of the SDLC is to produce software that meets a client’s business requirements.
The SDLC defines phases of the software development process that encompass their own process and deliverables.
It is a cycle of planning, design, and development that can be implemented as an iterative approach to software development. Adherence to the SDLC minimizes risks and costs to the development of high-quality, deployable software.

###### Its initial development in the 60s and 70s was driven by the need for a systematic approach because of the growing complexity of software.
The software development life cycle began to take shape in the mid-1960s as software development began to necessitate a more detailed approach because of its growing complexity. The SDLC led to a more deliberate approach as large corporations needed to manage complex business systems requiring heavy computational resources. In its initial conception, it used what is called the “waterfall method” to manage projects where the development of software follows a linear pattern through discrete stages. The SDLC has since been adapted, however, to more iterative methods in response to addressing customer needs and shifting requirements.
Waterfall and other approaches to software development will be discussed in another lesson.
###### key advantages for businesses in following the SDLC.
1.  improves efficiency and reduce risks.
	   it gives development teams a roadmap to the software development process to follow rather than using an ad hoc approach, increasing predictability to allow better preparation
2. Reduces Conflict and Overlapping Responsibilities
	SDLC Phases are clearly defined and discrete, facilitating clear designation of tasks and responsibilities to individual team members and stakeholders, allowing individuals to kunderstand what tasks they should be working on and when.
3. Increases Communication between the dev team, customers, and other stakeholders
	The SDLC offers an overview of the process in terms of well defined phases, so stakeholders know where they fit in to that process. and, since each phase is discrete, cross-domain teams know when they have completed theirtasks and when development can move to the next phase.
4. The ability to be used iteratively, allowing for changing requirements.
	The SDLC provides room for iteration where, at the end of a cycle, the process can circle back to incorporate additional requirements as needed.
	Problem solving is incorporated early in the cycle so problems are addressed in a timely fashion and can be addressed in the design phase rather than during coding.
##### Phases of The SDLC
###### There are generally six phases in the SDLC process. 
Each phase is discrete meaning that tasks from a previous phase do not overlap with tasks in the next phase.
The original SDLC was conceived as a traditional waterfall method where the phases are linear, but have since been adapted to introduce iteration so that shifting requirements can be accommodated.


| Phase           | Summary                                                                                                              | Notes                                                                                                                                                                                                                                                                                                         | Process                                                                                                                                                                                                                                                                                   | End Product                                                                                                 | Stakeholder Involvement                                                                                                                                                                      |
| --------------- | -------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1. Planning     | requirements are gathered, analyzed,<br>documented and prioritized.<br><br>then the SRS is developed                 | Consideration Factors when planning a software solution:<br>users of the solution, the overall purpose of the solution, data inputs and outputs, legal and regulatory compliance, risk identification, quality assurance requirements, allocation of human and financial resources, project scheduling.       | <br>Labor and material costs are estimated and weighed against time constraints.<br>Project teams are identified, and roles of each team member are proposed                                                                                                                              | Requirements Gathered are combined into a software requirements specification (SRS) document.               | The SRS needs to be clearly understood and approved by all stakeholders.<br><br>The developers are also involved at this stage so they can gain a clear understanding of these requirements. |
| 2. Design       | requirements gathered from the SRS are used to develop the software architecture and the design document is created. |                                                                                                                                                                                                                                                                                                               | Several team members work together at this stage to design the architecture.<br>The architecture is reviewed by the stakeholders and team.<br>During this phase, prototypes can be designed.                                                                                              | document created called a design document, and is used by developers during the Development Phase           |                                                                                                                                                                                              |
| 3. Development  | developers carry out the coding process                                                                              | This phase often requires the use of programming tools, different programming languages, and software stacks.<br>Organizations may also have standards or guidelines that need to be followed.                                                                                                                | The project planners use the design document to determine and assign coding tasks.                                                                                                                                                                                                        | finished code as outlined in the design document                                                            |                                                                                                                                                                                              |
| 4. Testing      | Issues with the code are found and fixed if possible                                                                 | Some large projects have dedicated testing teams.<br>Testing can be manual, automated, or a hybrid of both.<br>Some common levels of testing include<br>unit testing, integration testing, system testing, and acceptance testing.                                                                            | Product bugs are reported, tracked, and fixed, and code is retested until the software is stable.                                                                                                                                                                                         | Code to be thoroughly tested to ensure it is stable, secure, and meets the requirements outlined in the SRS |                                                                                                                                                                                              |
| 5. Deployment   | application is released into the production environment and made available to users.                                 | first, released onto a user acceptance testing (UAT) platform and once the customer signs off on the functionality, it is released to production.<br>This approach can be used for making software available on a website, mobile device app store, or a software distribution server on a corporate network. | can happen in stages<br>                                                                                                                                                                                                                                                                  | software deployed into a production environment.                                                            |                                                                                                                                                                                              |
| 6. Maintainence | feedback is collected from stakeholders, other UI issues may be identified, and code enhancements suggested.         | If bugs are discovered in this phase that were missed during testing, these errors may need to be fixed for high-priority issues or incorporated into the requirements as part of a future software release and the process can start over again.                                                             | find any other bugs, identify user interface issues, or UI for short, and identify other requirements that may not have been listed in the SRS. Code enhancements can also be identified at this stage. Information then can be fed into another software development cycle if necessary. |                                                                                                             |                                                                                                                                                                                              |
######  Variations Between Organisations
Note that some organizations may have different names for each stage. 
	For example, “planning” may be called “requirements” or “strategy” or “analysis”. 
	The development phase, sometimes called the “building" phase or the "implementation"
Also, some organizations may have additional or fewer stages.

###### Prototyping
If stakeholders are struggling to define requirements, often the development team may produce prototypes during the planning stage to tease out those requirements.
A prototype is a small-scale replica of the end product used to get stakeholder feedback and establish requirements.
A prototype is used to test basic design ideas.
Though prototyping usually occurs during the planning stage, prototyping can occur at various phases of the SDLC whenever requirements need to be reconsidered or clarified as the project develops.

In the design phase, prototypes can be designed. A prototype is a preliminary mock-up of the system, or parts of the system, used for demonstration purposes.

##### Building Quality Software
###### common software engineering processes required
Numerous processes that are common to software engineering projects.
six of them: requirements gathering, design, coding for quality, testing, releases, and documenting.

###### Requirements Gathering
The software requirements specification (SRS), encompasses the process of collecting and documenting the set of requirements that the software needs to adhere to. 
may include a set of use cases that describe the business needs and user flows the software must implement.
Software requirements can be classified into four broad categories:
functional, external and User Interface (UI), system features, non-functional.
###### Software design 
Designing transforms requirements into a structure that developers can use.
is the process of transforming the requirements into a structure that is implementable using code.
Translates the requirements into a language the developers can use to write the code. 
Transforms the requirements into a software solution.
The technical lead breaks down requirements into sets of related components with clearly defined behaviors, boundaries, and interactions. These components define the system architecture.
The system design incorporates guidance on system functions, performance, security, and platform characteristics.
The design communicates business rules and application logic, application programming interface design, which is how apps talk to each other or communicate with the database,user interfaces, and database design.
###### Code quality
characteristics of the code/ attributes such as maintainability, readability, testability, and security.
Quality code must fulfill the intended requirements of the software without defects.
clean and consistent, easy to read and maintain, well documented, and efficient.
Coding for quality entails following a set of coding practices during development. 
following common coding standards, conventions, patterns and styles, using automated tools (linters), to detect programmatic and stylistic errors, and commenting in the code itself to make it easy for others to understand and modify.
Coding for quality entails following a set of coding practices during development.
###### Software testing
is the process of verifying that the software matches established requirements and is free of bugs. 
Purpose is to identify errors, gaps, or missing requirements when compared with stated requirements. Properly tested software ensures reliability, security, performance, and efficiency.
Software testing can often be automated or done manually.

Levels of testing include unit, integration, system, and user acceptance.
- Unit testing is often done by the developer and tests the smallest component of code that can be isolated from the rest of the system.
- integration testing once the components are integrated into the larger product.
 - system testing after the larger product is deemed completed
- User acceptance testing (UAT / beta testing), when the software is tested by the intended end user. 
Types of testing can broadly be divided into three categories, functional, non-functional, regression. 
Testing is the process of verifying that the software matches established requirements and free of bugs
###### Software distribution
When the newest version of the software is distributed, it is referred to as a “release.”
Different types of releases are intended for different audiences.
There is generally three types of releases including: alpha, beta, and general availabilityan "GA” release. 
- GA stands for general availability.
	The audience for the GA release is all users.
- Alpha release = first functioning version of the system released to a select group of stakeholders.
	The alpha release likely contains errors and may not contain the full feature set but does contain most of the desired functionality.
	Design changes may still occur during this release stage.
- The beta release(limited release), is given to the stakeholders outside of the developing organization.
	One of the intents of the beta release is to try out the software under real conditions, test the functionality, and identify any outstanding bugs or errors.
	The beta release should meet all the functional requirements.
	after beta release changes are agreed upon, made, and tested, and a stable version is released.
###### Software documentation 
should be provided to both non-technical end-users and technical users.

System documentation is geared towards the technical user. 
Technical users may be other engineers, developers, or architects. System documentation explains how the software operates or how to use it. It consists of README files, inline comments, architecture and design documents, verification information, and maintenance guides.

User documentation is provided to the non-technical end-users to assist them in the use of the product. 
User documentation generally provided in the form of user guides, instructional videos and manuals, online help, and inline help.

documenting requires text or video that explains the software to technical and non-technical users.
​
##### Requirements
Describe the steps of the requirement gathering process.
Explain the purpose of a User Requirement Specification, or URS, document.
Explain the purpose of a Software Requirement Specification, or SRS, document, and
Explain the purpose of a System Requirement Specification, or SysRS, document

The requirement gathering process entails identifying stakeholders, establishing goals and objectives, and eliciting, documenting, confirming, and then prioritizing requirements. 

Requirement gathering is a six-step process of defining a problem to be solved and documenting how to go about solving that problem. 
These steps include:
- identifying stakeholders,
- establishing goals and objectives,
- eliciting requirements from the stakeholders, 
- documenting the requirements,
- analyzing and confirming the requirements, and 
- prioritizing

Generally, the stakeholders work for the org that requests the development of the software product.
Key personnel from the organization may include : decision-makers, end-users, system administrators, engineering, marketing, sales, and customer support personnel.
It is good to have a representative from every group that the product affects.
The goals of the product should be clearly defined.
Goals are broad, long-term achievable outcomes.
Goals can include customer outcomes and business goals.

Next, objectives should be identified. 
	Objectives are more specific than goals → actionable and measurable actions that achieve the stated goals.

The next three steps, eliciting, documenting, and requirement confirmation are usually completed iteratively. 
	Elicitation can be accomplished through surveys, questionnaires, and interviews. As the requirements emerge, they should be documented and checked to ensure they align with the goals and objectives.
	Documented requirements should be easily understood by stakeholders and the project team. In order to confirm the requirements, they should be analyzed to ensure consistency, clarity, and completeness. And after analysis, the requirements should be shared with and approved by the stakeholders.
	After confirmation, requirements should be prioritized. 
		Labels such as “must-have,” “highly desired,” and “nice to have” are helpful. If possible, order the requirements within those categories.

Typically, there may be three documents that result from the requirements gathering process:
software requirements specification, or SRS,
user requirements specification, or URS,
and system requirements specification, or SysRS. 

The most common of these is SRS,
is a document that captures the functionalities that the software should perform and also establishes benchmarks or service levels for its performance.
	Parts of an SRS include:
	A purpose statement that contains the intended use of the SRS, its audience and scope, constraints, assumptions and dependencies, and requirements, which can be sorted into four categories:
		Functional requirements
		External Interface requirements
		System Features
		and Non-functional requirements
The product’s purpose describes who will have access to the SRS and how they should use it.
The scope describes the benefits of the software, its goals, and objectives.

The second part of the SRS should detail constraints, assumptions, and dependencies.
Constraints describe how the product must operate under given conditions that may limit options in the design phase such as confirmation to standards or hardware limitations.
Assumptions may include things like a required operating system or hardware that is needed by the software to function.
Dependencies on other software products should also be noted.
Requirements can be classified into four categories.
	Functional requirements are those that cover the functionalities of the software.
		System features are a subset of functional requirements. These are required features for the system to function.
	External requirements are the requirements that address the behavior of the software in relation to external entities such as users and interactions with other hardware or software.
	Non-functional requirements such as specifying performance, safety, security, and quality standards.
	User requirements describe the business need and expectations of the end-users from the software system.
		The user requirements are written as “user stories” or “use cases” that answer three questions:
			Who is the user?
			What is the function that needs to be performed?
			And why does the user want this functionality?
			User acceptance testing determines if these requirements have been met.
	Often though, the user requirements and software requirements are combined into a single SRS document. The SRS details the expectations of the software system.

The System Requirement Specification document, or SysRS, to differentiate it from the SRS, clearly outlines the requirements of an entire system. The system requirement specification is often used interchangeably with software requirement specification, but the SysRS is actually broader in scope than the SRS.

Many software projects develop an SRS rather than a SysRS.
The SysRS contains system capabilities, interfaces, and user characteristics.
	It also may include policy requirements, regulation requirements, personnel requirements, performance requirements, security requirements, and system acceptance criteria.
It also outlines expectations of the hardware needed for the system in addition to software requirements.

The SRS documents functional, external, system, and non-functional requirements.
The URS documents user stories.
SysRS documents system capabilities and acceptance criteria, and policy, regulation, personnel, performance, security, and hardware requirements.

#### The Software Building Process and Associated Roles
##### Software Dev Methodologies
- [ ] list several commonly used approaches to the software development life cycle,
- [ ] explain waterfall, V-shape model, and Agile methods,
- [ ] compare the pros and cons of each of these three methods.

There are many ways to approach software development.
A specific methodology for developing software is commonly used in order to assist the dev team to clarify communication among team members and determine how and when the information is
shared. three of these approaches: Waterfall, V-shape model, and Agile.

waterfall and V-shape are sequential whereas Agile is iterative
both waterfall and V-shape models are easy to implement but neither accommodates changing requirements well and Agile allows for changing requirements but resource allocation can be challenging.
###### Waterfall
In the beginning, when the SDLC was conceived, it implemented the waterfall method.
Waterfall is a sequential method of software development where the output of one phase is the input for the next phase of the cycle.
Development and work on the next phase start only after the completion of the previous phase.
All planning, such as defining requirements and architectural design, is done up front.
The customer usually does not see the product until it is in the testing phase.
For a major version release of the product, the same process is repeated resulting in long intervals, such as years, between releases.

######  V-shape model 
is named as such because the phases form the shape of a V.
The phases going down the left side of the V are called “verification".
Then, going up the right side of the V, those phases are called, "validation."
The V-shape model is like waterfall in that it is also sequential.
Each phase in verification corresponds with a validation phase.

There are four stages that occur on each side of the V. Going down the V are planning, system design, architecture design, and then module design.
The bottom of the V is the coding phase.
And going back up the V are the four phases that correspond to the phases going down the V: unit testing, integration testing, system testing, and acceptance testing.
The tests are written during the verification phases on the left and executed during the validation stages on the right.
###### Agile Model
It focuses on a collaborative software development process over multiple short cycles rather than a strictly top-down linear process.
Agile is iterative approach to development.

It still aligns with the SDLC, but each phase is short.
Teams work in cycles, or sprints, which are usually one to four weeks long.

Unit testing happens in each sprint to minimize the risk of failure.

Rather than the “maintenance” stage of the SDLC, the final stage of the sprint is a feedback stage.
At the end of each sprint, a chunk of working code is released at a meeting called the “sprint demo” where stakeholders can see the new functionality and provide feedback.
After the sprint demo, the entire process is repeated for every sprint cycle.
After several sprint cycles, a minimum viable product, or MVP, is developed so stakeholders can provide feedback on the basic feature set.
The MVP contains a feature set to validate assumptions about the software.

The four core values of Agile development outlined in what is known as the "Agile manifesto" are:
	individuals and interactions over processes and tools
	working software over comprehensive documentation
	customer collaboration over contract negotiation, and
	responding to change over following a plan.

###### comparing models
The main difference between traditional SDLC methods such as waterfall and the v-shape model compared is  they are sequential whereas Agile is cyclical.
Traditional SDLC methods, such as waterfall and V-shape, center around the whole product being developed before soliciting customer feedback, whereas
Agile focuses on quick, short bursts of development.
Agile is probably the most popular method used in modern software development.


|           | pros                                                                                                                                                                                                                                                                | cons                                                                                                                                                                                                                                                                            | other                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| waterfall | easy to understand and follow. → Each stage is discrete and well-defined, making it easy for all team members to understand their roles. <br>Also, since planning is done upfront, it is easier than iterative methods to estimate a budget and allocate resources. | lacks flexibility. Since all planning is done upfront if a requirement is changed or overlooked that change can be<br>hard to incorporate at a later date. Inevitably, unforeseen complications happen, or agreed upon functionality shifts from what was initially envisioned. |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| v-shape   | simple and easy to use.<br>but designing test plans during the verification phase saves considerable time during coding and validation phases.                                                                                                                      | <br>Drawbacks are also similar to waterfall because it does not readily accommodate changing requirements.<br>Once an application is in the testing phase it is extremely difficult to go back and change functionality.                                                        | even more rigid than waterfall                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| agile     | new, and changing requirements are handled quickly and easily because planning is initiated at the beginning of each sprint cycle.<br>makes full use of modular nature of recent coding languages and technologies                                                  | upfront planning such as budgeting and scheduling can be challenging because the overall scope of the product is not clearly defined.                                                                                                                                           | relying on ongoing research, planning, and testing during product development. When adding new features to a project, development still goes through the same phases as in traditional SDLC<br>Most resources are spent on the building phase. At the end of each cycle, the QA team, stakeholders, and the customer have some piece of working code to test against requirements and are encouraged to provide feedback. As coding languages and technologies have developed in recent years, they now allow for modular design, where developers can focus on smaller chunks of code that are readily integrated into the larger product. These small chunks can be released to provide the MVP. |
##### Software Versions
- [ ] Discuss software versions on computing platforms
- [ ] identify software versions and numbering.

Software versions gives info about programs and applications.
Users can determine what software version they are using, and developers can provide useful information with version numbers.

###### Software version numbers 
Version numbers indicate the history of changes, updates, and patches to software,
Some version numbers follow the semantic numbering system and have 4 parts separated by a period,

Software versioning is how software developers keep track of new software, updates, and patches for programs and applications.
version numbers vary in length and meaning; however, most version numbers follow a similar format and represent similar information.

Version numbers indicate when the software was released, when it was updated, and if any minor changes or patches were made to the software.
Version numbers can be displayed in several ways. can be short or long, depending on the software and the preference of the developer, with 2, 3, or 4 number sets. Each number set is divided by a period.
	The first release of an application or program might have a 1.0 as the version number to indicate no updates, patches, or fixes to the software.
		Note: A version still in beta or testing could have a version number lower than 1, such as 0.9.
		A program or application with many releases and updates will have a longer number, sometimes 4 different number sets within the version number
			Some software developers may use dates for their versioning.
				For example: Ubuntu Linux version 18.04.2 was released in 2018 April.
					The third number set, point-2, designates an additional change or update.
			Some version numbers follow the semantic numbering system and have 4 parts separated by a period, but not all numbering systems follow this 4-part example.
			In semantic numbering, the first number indicates major changes to the software, such as a new release.
	The second number indicates that minor changes were made to the software.
	The third number in the version number indicates patches or minor bug fixes.
	Finally, the fourth number indicates a build number or a build date, and it can indicate less significant changes made.

Software version numbers are identified in the About or Help section of software.

###### compatability between versions
Lack of compatibility between old and new versions of software is a common problem. and you should view the version of the software you are using to determine software compatibility.
You can troubleshoot compatibility issues by viewing the software version to determine if you are using an outdated version of the software.
Sometimes updating software to a newer version will resolve compatibility issues.
Some software is backwards compatible.
If a program or application is backwards compatible, then the older versions of files, programs, and systems will work properly with newer versions.

##### Software Testing
- [ ] Define the terms functional testing, non-functional testing, and regression testing,
- [ ] compare and contrast typical testing levels.

Software Testing is the practice of integrating quality checks throughout the software dev cycle.
The purpose of testing is to
	check whether the software matches expected requirements
	ensure error-free software.
###### Test Cases
In order to test software, the team writes “test cases”  to verify the functionality of a software application and ensure requirements have been satisfied.
Test cases can be written in different stages of the SDLC and may vary depending on the type of test or the method used to develop the software, such as Agile or waterfall.

A test case contains: steps, inputs, data, and the expected corresponding outputs. 

Regardless of the test type or development method, test cases should always be written after requirements are finalized.
Software testing helps evaluate the software to identify whether or not the software product meets requirements and is error-free.

###### Types of testing 
can be broadly classified into three categories:
	Functional testing,
	Non-Functional testing,
	and Regression testing

###### Functional testing 
usually involves black box testing which is a method of testing without looking at source code or internal structure.
Functional testing is only concerned with inputs and corresponding outputs of the system under test, also called the SUT. It is entirely based on testing functional requirements.
Functional testing can be carried out manually or using automated tools.
The goal is to test the functionality of the application making sure the application is usable and accessible. 
Functional testing tests the SUT, to make sure it meets functional requirements.
Functional testing makes sure that when user errors or input edge cases do occur, the software handles those exceptions seamlessly by displaying appropriate error messages.

###### Non-functional testing 
includes testing the application for attributes like performance, security, scalability, and availability.
Non-functional testing checks to see if the SUTs non-functional behavior is performing properly.
Non-functional testing should answer questions like the following:
	How does the application behave under stress?
	What happens when many users log in at the same time?
	Are the instructions in documents and user manuals consistent with the application’s behavior?
	Does the application behave similarly under different operating systems?
	How does the application handle disaster recovery?
	And how secure is the application?
	
###### Regression testing (maintenance testing)
confirms that a recent change to the application, such as a bug fix, does not adversely affect already existing functionality.
Regression testing should occur when there has been a change in requirements or when defects have been fixed.
In order to conduct regression testing, all or some of the test cases should be selected to test against the application. Regression test case selection and prioritization can be challenging and can depend on several factors.

Common reasons for regression test case selection include cases that:
have frequent defects , contain frequently used functionality, contain features with recent changes, or are complex test cases, edge cases, and randomly successful or failed test cases.
###### testing levels.
There are four testing levels: unit, integration, system, and acceptance.

Each level occurs at a different time in the SDLC. 
There are 4 different levels in order to reduce the amount of time spent on testing by preventing overlap.
###### Unit testing 
Unit testing verifies small, independent chunks of code.
refers to tests that verify the functionality of a specific section of code, usually at the function level.
It is performed by the software developer or engineer during the development phase of the software development life cycle.
Unit testing aims to eliminate construction errors before code is integrated with other modules. Unit testing is intended to increase the quality of the resulting software as well as the efficiency of the overall development process.
###### Integration testing
Integration testing looks for errors when two or more small chunks of code are combined.
seeks to identify errors when two or more smaller, independent code modules are combined.
Integration testing is another type of black-box testing.
Prior to integration testing, smaller, independent code modules that passed unit testing are incorporated into the larger software application.
After modules are integrated together, then integration testing can occur. Integration testing exposes bugs that occur when those smaller units of code interact with each other.
Integration testing uncovers deficiencies in communication with a new module in conjunction with other existing modules, databases, or external hardware. Integration testing uncovers situations where bugs develop due to differing programming logic between modules, for instance. 
Also, sometimes during module development, requirements change, and the module isn’t fully unit tested. 
Poor exception handling can cause problems when modules are integrated together.
###### System testing 
System testing validates the system as a fully completed software product 
occurs after integration testing and is conducted on a complete, integrated system to evaluate the system's compliance with its specified requirements.
It validates the system as a fully completed software product.
System testing is both functional and non-functional.
System testing is done in a staging environment, which should be similar to the production environment. 
###### acceptance testing 
acceptance testing verifies correct implementation of user requirements and business processes.
is formal testing with respect to user needs, requirements, and business processes. It determines whether a system satisfies the needs of the users, customers, and other stakeholders.
Acceptance testing is usually done by the customer or the stakeholders during the maintenance stage of the SDLC.
##### Software Documentation
- [ ] List documentation formats.
- [ ] Compare and contrast product documentation to process documentation.
- [ ] Describe the categories and types of documentation.
- [ ] explain the purpose of standard operating procedures.

Software documentation is information about the software that describes what the product is and how to use it. 
These can be written, video, or graphical assets associated with a software product’s development and use.
Documentation comes in three formats: written, video, or graphical.

Documentation is an essential aspect of software engineering applicable across all the phases of SDLC.
Software Documentation can be written for different types of audiences – such as end users, software developers, QA engineers, system administrators and other stakeholders.

Documentation can be divided into two categories, product and process.
	Product documentation relates to the product’s functionality, whereas process documentation describes how to complete a task.
	Process documentation should provide the requirements for the quality implementation of a business process.
Process documentation describes how to complete a task.
Product documentation relates to how a product functions.
###### types of product documentation.
There are many types of documentation, and we will discuss five categories including requirements, design, technical, quality assurance, and user documentation.

Requirements documentation 
	is written during the planning phase of the SDLC and is intended for the development team including the developers, architects, and QA personnel.
	Requirements documentation describes the expected features and functionality of the software system.
	It includes the software requirements specifications, system requirement specifications, and user acceptance specifications.
Design documentation 
	is written by the software architects and the development team to explain how the software will be built to meet the requirements.
	It consists of both conceptual and technical design documents.
Technical documentation 
	includes comments written in the code to help other developers read the code to understand its behavior. It also may include working papers that explain how the code works and documents that record engineers’ ideas and thoughts during project implementation.
Quality assurance documentation 
	includes all documents that pertain to a testing team’s strategy, progress, and metrics.
	Types of test documentation include test plans, test data, test scenarios, test cases, test strategies, and traceability matrices. Traceability matrices map test cases to their requirements.
User documentation 
	is intended for end-users and explains how to operate the software or help them to install or troubleshoot the system.
	End-user documentation includes frequently asked questions, installation and help guides, tutorials, and user manuals.
###### Standard operating procedures (SOPs) and Process Documentation
SOPs often accompany process documentation. SOPs are written instructions detailing an organization's specific procedure.
​
Process documentation provides an overview of a process, but SOPs go through much greater detail. 
The SOP is written documentation that explains step-by-step how to accomplish a common, yet complex task that is organization specific. For example, checking in code using a code repository is common knowledge for a software engineer.
However, an organization might have specific steps to follow for that organization in order to get code merged into the main branch.
The SOP documentation explains those steps in detail. SOPs can be in the form of a flowchart, a hierarchical outline, or step-by-step instructions.
###### Maintaining Documentaion
Documentation, in any form, must be kept up to date.
	Take for instance online user manuals. If a cloud-based application user interface changes, then the accompanying online documentation must be updated accordingly. Businesses need to ensure they allot resources for this step.
With regards to the software development and the SDLC, updating documentation happens during the maintenance phase.
Ideally, documentation should also be reviewed periodically to ensure its accuracy.

##### Roles in Software Engineering Projects
- [ ] list the common roles on a software engineering project,
- [ ] describe each role, and explain the responsibilities of each role.

There are several common roles on a software development project. And these roles can have different names depending on the approach being used, such as Agile or waterfall. Sometimes different companies have different names for similar jobs. But, not all projects will have all these roles. The roles we will discuss in this video are project manager or scrum master, stakeholder, system or software architect, UX designer, software developer, tester or QA engineer, site reliability or Ops engineer, product manager or owner, and technical writer or information developer. 

###### Project Managers/ Scrum Masters
Traditional SDLC methods have project managers but in Agile the equivalent role is called a Scrum master. A project manager makes sure the project runs smoothly and facilitates communication about the project.

The project manager often deals with bigger picture issues such as:
	Planning, scheduling, and budgeting; Allocating personnel and resources; Executing the software plan; and Team communication.
In Agile, there is a Scrum master. Rather than focusing on planning, the Scrum master is focused on ensuring team and individual success.
	The four core Agile values prioritize people and communication over process, and the Scrum master is responsible for facilitating that communication.
###### The stakeholders 
are the people for whom the product is being designed.
They include individuals such as the customer, end-users, decision-makers, system administrators, and other key personnel. The stakeholder is mainly responsible for defining project requirements and providing feedback if the team members need clarification on requirements or if a proposed solution cannot be solved as planned.
The stakeholders may also sometimes participate in beta testing and acceptance testing before the software is released.
###### system architect/ software architect/ solution architect
designs and describes the architecture of a project as well as communicates that architecture to team members.
They are responsible for designing the essential characteristics of the inner structure and technical aspects of the software.
The architect provides technical support across the different stages of the SDLC.
###### UX means user experience.
The goal of a UX designer is to balance making the software intuitive but also as robust as it needs to be to address requirements.
They define how the software behaves from the user’s perspective.
The UX designer determines how the software communicates its functionality to the end-user and how the end-user interacts with it.
###### developers 
write the code that powers the software.
Responsibilities include implementing the architecture laid out in the design document, incorporating the requirements laid out in the software requirements specification, and employing the UX requirements determined by
the UX designers.
###### Testers/QA engineers 
are in-charge of ensuring the quality of the product and that the software solution meets customer requirements.
They are responsible for writing and executing test cases to identify bugs or deficiencies and provide this feedback to the development teams.
###### site reliability engineer (SRE)/ ops engineer,
bridges development and operations by combining software engineering expertise with IT systems management. They track incidents and facilitate meetings to discuss them. 
They also automate systems, procedures, and processes; assist with trouble shooting; and ensure reliability for the customer.
###### product manager/product owner 
has the vision of what the product should look like.
They have an intimate understanding of the client’s requirements, and the end-user’s needs. 
They are responsible for leading development efforts to create the software and for ensuring the product provides the value stakeholders are looking for.
###### technical writer/ information developer
writes documentation for the end-user. 
They write documentation on technical material geared towards a non-technical audience. 
Not only does this documentation help the end-user to use the software, but it also helps the customer so they can provide timely feedback to the development teams. 
Technical writers may be asked to write user manuals, reports, white papers, and press releases.
##### Insiders' Viewpoint: Job Roles in Software Engineering Teams
Welcome to Insiders’ Viewpoints: Job Roles in Software Engineering Teams.
In this video we will hear from experts discussing the various job roles you can expect to work with on your Software Engineering team.
On the engineering team I worked with, we had a product manager, we had a tech lead, we had a QA, we had a few QA analysts or test engineers. And we also had access to UX designers. And so the product manager ensured that we were on task and on track to deliver the features that we said we were going to build according to the business needs, that way we're not left behind. Yeah, I think, in my experience, the roles that the software engineers would interact with the most, I think would, you know, in no particular order product managers, so the folks who are actually sort of working with the sales teams, the marketing teams, figuring out what actually needs to be built, what our customer needs, what are innovations and ideas that, you know, looking forward, that we might, you might want to invest in and build out. We asked our experts to describe these job roles in software engineering teams in further detail I think software engineering these days, as it becomes more and more, more more and more large scale, more complex more systems at play. More considerations, there's just a lot of things to consider in today's in today's world as a software engineer, so you often work with a project or program manager who helps you set up your timelines, helps you ensure you're meeting your goals, helps you unblock yourself helps you keep your stakeholders community up to date with what is what is happening with your project. So there's just a lot of pieces involved. And I think project and program managers really are there to help tie it all together. So the product manager would always act somewhat like a scrum master. So like, we would have stand ups. And we would talk about the tickets that we had in JIRA. And it was it was like, okay, so what are you working on?
What do you need help with? And are there any issues. And during that process, the product manager does ensure that we were on task and on track, and if we had any issues, he would help us to resolve it. You'll have a software engineer who's more focused on the architecture and they can keep the the big picture in their brain more easily. And then some software engineers who are more than nitty gritty, I'm sitting down and I am writing code and my my job is to like, turn business logic into computer logic. And some companies have those all split out as different roles. I think software engineers, and then these roles that the more they're embedded and work closely together and actually collaborate as part of a single team. versus handing off things in a more waterfall approach. I think that that's generally the the best way, or was one of the most effective ways is to actually work together as much as possible regular check ins, actually having, you know, brainstorming sessions, group chats that involve all the various folks, all the roles, I think, close collaboration, there is super key And at some companies, all the different hats have their own titles. So you might be talking to a software engineer who's actually doing more kind of DevOps infrastructure building, monitoring and alerting kinds of work. And then there's a software engineer who's also doing QA work. And they're the ones who are focusing on pipelines and continuous continuous development, continuous integration type projects, working on getting test suites and automation all set up. In terms of working with the UX designer or the UX engineer, they would give me like specific specs from figma. In order to meet the certain specifications of the business, it's let's say, we're building a checkout page. So the UX UX designer would design the spec page and figma and then deliver that spec to me, and then I would code it according to the design. UX designers who actually come up with it, if you work, if you're working on an engineering or user interface, you work with UX designers to, to essentially from the moment of sketching out sort of a, you know, a draft on paper or whiteboard of an idea all the way down to working with them on mocks and implementing the mocks iterating. On those UX researchers often are worked with when you actually need to go out and do research and market and interview your partners or customers to get sort of as real time as possible.
And just, you know, real feedback from real users of your, of your software. So once I code something, I get it reviewed by my tech lead or my senior engineer, it would go to QA for them to test the application to ensure that whatever I did or implemented, didn't break anything. If something is broken, that I didn't catch, the QA tester would write up like a test plan or would do like a detailed testing document. That way I understood exactly what needed to be resolved. And I would resolve it, and then go back to the QA person and say, Hey, this is fixed, can you take a look at it again, and they would tell me whether or not it's fixed and whether or not something else was broken, which often happens with code. So you know, you generally work a lot with product managers, because you need to know what to build. And they generally give you a lot of guidance on, on what they want to build, and you collaborate with them in terms of how to build it and discuss trade offs and timelines, and expectations. So it's a very much a collaborative process. Typically, I have found that I interact most with product owners. So either at some places, it's been a customer who works inside the company. And so I go to them quite frequently for questions on clarifying refinements for getting test schedules up and running for figuring out pain points and trying to optimize their workflow workflows using technology to support them. Software engineers work often with site reliability engineers, or Sysadmins is maybe there, the role could be called to actually maintain and help run the software and deploy it and actually get it running somewhere that's not on your desktop, you often work with more dedicated test engineers who are responsible for end to end testing, automated testing, integration testing, at all, at all points of the lifecycle. So as an engineer, you're never alone. You're never working alone. It's just a matter of like knowing how to communicate directly with the people on your team
​


#### Summary and Quizzes
##### Summary
Software engineering is the application of scientific principles to the design and creation of software. 

Responsibilities of a software engineer include designing, building, and maintaining software systems.  

Using the SDLC can improve efficiency and reduce risks by:  
	letting team members know what they should be working on and when  
    facilitating communication between the customer, other stakeholders, and the development team 	
    letting stakeholders know where they fit into that process and  
	letting cross-domain teams know when they have completed their tasks so development can move to the next phase.   

Common software engineering processes are requirements gathering, design, coding, testing, releasing, and documenting. 
The requirement gathering process entails identifying stakeholders, establishing goals and objectives, eliciting requirements from the stakeholders, documenting the requirements, analyzing, prioritizing, and confirming the requirements. 

 SRS is a document that captures the functionalities that the software should perform and also establishes benchmarks or service levels for its performance. 
URS is a subset of the SRS that details user specification requirements. 
SysRS contains the same information as an SRS, but can also additionally include system capabilities, interfaces, and user characteristics, policy requirements, regulation requirements, personnel requirements, performance requirements, security requirements, and system acceptance criteria. 

Waterfall, V-shape model, and agile are all different methodologies for implementing the software development life cycle. 

 Functional testing is concerned with inputs and corresponding outputs of the system under test, non-functional testing tests for attributes such as performance, security, scalability, and availability. Whereas regression testing confirms that a recent change to the application, such as a bug fix, does not adversely affect already existing functionality. 

   Types of documentation include requirements, design, technical, quality assurance, and user. 
       
   There are many different roles involved in a software engineering project. Some of them include project manager or scrum master, stakeholder, system or software architect, UX designer, software developer, tester or QA engineer, site reliability or Ops engineer, product manager or owner, and technical writer or information developer. 


### Module 2 : Intro to Software Dev
#### Learning Objectives
#####  Learning Objectives
 This module introduces you to the concepts of application development. In lesson 1 you’ll learn about the differences in front-end and back-end development in web and cloud applications and the technologies used in both. You’ll also learn about how working in teams and pairs can enhance the development process and make it more efficient. In lesson 2 you will explore many of the application development tools that a software engineer uses to write, test, and release code and be introduced to software stacks that support the execution of an application. Finally, in the hands-on lab, you’ll learn how to use an integrated development environment (IDE) to develop and run code.
Learning Objectives
- [ ] Describe how websites and cloud applications work.
- [ ] Identify the technologies you can use to create reactive and responsive websites.
- [ ] Identify the back-end technologies you can use to create functionality in your websites.
- [ ] Describe how teams and squads work in a software engineering context.
- [ ] Identify the benefits of different pair programming styles.
- [ ] Classify common web technologies into front-end and back-end technologies.
- [ ] Identify commonly used types of development tools, including version control software, libraries, and frameworks.
- [ ] Describe how some key developer tools work, including CI/CD tools, build tools, packages, and package managers.
- [ ] Describe software stacks and identify the advantages of three popular stacks.
- [ ] Identify parts of an IDE and use them to create a simple software application.
#### Intro to Development
##### Overview of Web and Cloud Dev
When you’re starting out as a Web Developer, it can be difficult to determine what you need to learn and what order you should learn it in.
Understanding how familiar websites are constructed and delivered to you is a good starting point.
The basic communication between client and servers
How websites are built and displayed.
###### How websites work
Let’s review the basics of how you interact with a website.
	You launch an internet browser – there are lots available:
		Google Chrome, Microsoft Edge, Mozilla Firefox, and Apple Safari are some of the most popular.
	The browser has an address bar, into which you enter a URL, like www.IBM.com.
	The browser then contacts the server with the name and requests the information that makes up the website.
	The server then sends a response, which contains the data that the client requires to display the website.
	For most websites, the server will return:
		HTML, which defines the structure of the page, but doesn’t look very attractive
		CSS, which adds style and flair to the page and JavaScript, which adds interactivity and dynamic content.
	Content displayed by websites can contain elements that are either previously stored on the server (called “static”) or generated each time they are requested by the client (called “dynamic”).
		Dynamic elements can involve information coming from other systems and applications, such as databases.
		Most websites contain static and dynamic elements to provide the best user experience.

######  How cloud apps work
Cloud Applications are similar to Websites in that they request content that a server returns.
Cloud Apps are built to work seamlessly with a Cloud-based back-end infrastructure, Cloud-based data storage and data processing, and other Cloud services, making them very scalable and very resilient. 

###### front-end back-end fullstack
The environment for building websites and Cloud Applications is divided into two primary areas: front-end and back-end.
	The front-end deals with everything that happens at the client-side – everything the user can see and interact with.
		You can choose to specialize in front-end coding, using HTML, CSS, JavaScript and related frameworks, libraries, and tools.
	The back-end deals with everything that happens on the server before the code and data are sent to the client.
		The back-end coding usually handles the logic and functionality that make the website or app work, and the authentication processes that keep data secure.
		Back-end developers may also work with relational or noSQL databases, even collaborating with database administrators in bigger projects.
	Full-stack developers have skills, knowledge, and experience in both front-end and back-end environments.
Front-end development is about what happens on the client side.
Back-end development is about what happens on the server.
Full-stack development incudes both front-end and back-end development.

###### tools for dev
Whichever way you choose to specialize, you will need the appropriate tools to help you work. IDEs will help you create and manage your code.
​
The first tool most developers add to their resources is a code editor.
Developers also need tools to integrate, build, compile, and debug code.
	Integrated Development Environments or IDEs incorporate some of these additional capabilities beyond just code editing and make it easier to build and manage your code.
	Good IDEs support multiple languages and integrate with management and storage tools like Git and GitHub.
	Other useful features are custom extensions and themes for supporting your working style and environment.
		Examples for code editors and IDEs include Sublime Text, Atom, Vim, VS Code, Visual Studio, Eclipse and NetBeans.
##### Learning Front-End Dev
Internet websites offer lots of different services, one of the most popular being online shopping. 
When you explore an online shopping website, navigating through pages, choosing different product categories, or comparing products, you are interacting with the front-end of a website.

Let us see how the front-end of a website is developed by front-end developers.
For this, we need to understand how a website is made.
	To create a website, web developers usually use Hypertext Markup Language (HTML), Cascading Style Sheets (CSS) and JavaScript. 
	These languages are designed to work in conjunction with each other.

###### HTML is used to create the physical structure of a website.
The physical structure contains elements such as text, links, images/videos, page dividers and buttons.	
The HTML code ensures a proper formatting of all text and image elements so that browsers display the page consistently.
###### CSS
The backend developer codes the structure of the website.
A website is like a house which has only been constructed.

Just like we need interior designers to add style to a space, we need front-end developers to add the necessary glamor and appeal to a website.
When you order products from any website, you realize that the pages have a pleasing font, attractive colors, and are easy to navigate.

Developers use CSS to create stylish websites.
CSS provides front-end developers with a standard method to define, apply, and manage different sets of style characteristics for a website and each of its components.
CSS ensures uniformity in look and feel, style, colors, fonts, designs and layouts.

CSS is also used to create websites that have cross browser compatibility which means that they are compatible with multiple browsers and multiple devices such as PC, mobile devices, iPads etc.

###### Javascript
Online shopping websites are intuitive, interactive and quick to load. This is where JavaScript comes into the picture.
JavaScript is an object-oriented programming language that is used in conjunction with HTML and CSS to add interactivity to a website.

For example, you use HTML to add a login button to a page, and CSS to style that button.
	You then use JavaScript to add log-in functionality to that button.

###### SASS
A new front-end development language is Syntactically Awesome Style Sheets called SASS.
It is an extension of CSS that is compatible with all versions of CSS.
SASS enables you to use things like variables, nested rules, and inline imports to keep things organized.
SASS allows you to create style sheets faster and more easily.
###### LESS
Another language that is being used now is Learner Style Sheets or LESS.
LESS enhances CSS, adding more styles and functions. It is backwards compatible with CSS.

Less.js is a JavaScript tool that converts the LESS styles to CSS styles.

###### Web Design
Using all these languages, websites are designed as reactive and responsive.
Reactive or adaptive websites display the version of the website designed for a specific screen size.
	For example, a website can provide more information if opened on a PC than when opened on a mobile device.
Responsive design of a website means that it will automatically resize to the device it is being accessed from.
	For example, if you open up a products website on your mobile device, it will adapt itself to the small size of the screen and still show you all the features.

###### A JavaScript framework 
is an application framework that is written in JavaScript.
Programmers can manipulate the different functions, use them wherever required and can create device responsive applications.

A few examples of several frameworks being used are:
	Angular framework: an open-source framework being maintained by Google.
		Angular frameworks allow websites to render the HTML pages quickly and efficiently.
		It has built-in tools for routing and form validation.
	React.js has been developed and maintained by Facebook.
		It is a JavaScript library that builds and renders components for a web page.
		It is not a complete suite of tools.
			For example, routing is not a part of this framework and will need to be added using a third-party tool.
		React.js only helps build and drop components into a page.
	Vue.js is maintained by the community and its main focus is the view layer which includes user interface, buttons, and visual components.
		It is flexible, scalable and integrates well with other frameworks.
		It is very adaptable. It can be a library, or it can be the framework.

The task of a front-end developer evolves continuously.
The technologies are upgraded constantly and so front-end developers needs to keep upgrading the websites that they create.
The websites that they create should work in multiple browsers, multiple operating systems and multiple devices.
​
###### front and backend collab
A front-end developer creates websites and Cloud applications using HTML, CSS, and JavaScript to create what the user sees and interacts with in the client's software.
A back-end developer creates and manages all the resources that are needed to respond to the requests that the user makes through the client.

The back-end developers tasks focus on enabling this server infrastructure or back-end to process requests, supply data, and provide other services securely.
Front-end and back-end developers must work together very closely. Each needs to understand the requirements of the solution and how their respective parts will interact before the development process can begin.

Throughout the life cycle of the website or Cloud app, front-end and back-end developers collaborate to resolve issues and add functionality.
##### The Importance of Back-End Dev
How does the work of a back-end developer affect you as you are browsing the Internet or using a Cloud App? When you're shopping online, what happens to the data you enter? Your login information, your product searches, your payment info. The back-end processes all of these things. The back-end developers write and maintain the parts of the application that process the inputs. Let's think about your experience as you explore an online shopping site and make a purchase. As you search for products, your search request is submitted to a web application, which then retrieves the data from a separate database and serves it back to the client for display.
To facilitate this, a back-end developer must understand the language that the web application uses, how to query the database for the correct data, and how to bring the two together.
Even a simple task like navigating around the site can require the skills of a back-end developer. Many sites have restricted areas that are only available to users who have an account and have logged in.
User account management, authentication and authorization can be the responsibility of the back-end developer too.
Once you've decided what you want to purchase, you must add it to your card and make a payment. The purchase process requires you to submit sensitive information such as your address and credit card number.
The back-end developer must ensure that this data is securely handled and stored.
Front-end client interactions, whether a request for data, like an image, accepting input from a user filling out a form, or securing sensitive information like a credit card number, all require different services from the backend server.
Each request needs to interact with the back-end in a different way. 

Back-end developers use APIs, routes, and endpoints to process incoming requests.

An API is code that works with data, usually using JSON or XML.
APIs have set rules and structure.

A route is a path to a website or page that the user interacts with.
Routes generally take user input and show results based on the input and end point maybe an API or may simply be a path.
When a request from the front-end arrives at the back-end, it is routed to the correct service.
If the back-end has an endpoint defined for the request by using routing, the request will be addressed and replied to.
If the endpoint is missing, the server returns a 404 error.
Back-end developers must create and maintain this server side routing.
Along with back-end APIs, routes effectively allow the front-end client to plug into the correct socket at the back-end.
APIs provide a mechanism for Cloud apps, mobile apps, and other types of software to access resources from the back-end.

To perform all this back-end development, you will need to be familiar with at least one back-end language and its associated frameworks.

Among the most popular languages today is JavaScript, which was originally designed to run in web browsers, adding extra interactivity and dynamic content to web pages. JavaScript is also being used on the back-end with
new releases adding server-side functionality.
	JavaScript has many frameworks, but two of the most well-known are Node.js and Express.

Python is another popular language. It's very flexible and easy to learn. Python has wide functionality. It can be used for everything from creating webpages to connecting to a database, to performing data analysis.
	Two well-known Python frameworks are Django and Flask.

Back-end developers often work with data and databases.
You will also benefit from learning some SQL. To help handle requests from databases,
can use object relational mapping tools or ORM to connect to the databases and retrieve the correct data.
Although an ORM can hide some of the complexity of querying databases, it's useful to understand the fundamentals of databases so that you can troubleshoot any issues that arise.
The day-to-day tasks of a back-end developer focus on the behind the scenes functionality that keeps websites, Cloud apps, and mobile apps up and running.
Back-end development covers a wide range of technologies, from managing user accounts, authentication and authorization to ensuring that sensitive data is stored and transferred securely.
Back-end developers also work with databases, retrieving, processing, and storing data as required.

##### Teamwork and Squads
- [ ]  define teamwork and describe the advantages of collaboration in software engineering and describe squads.

By definition, a team is a group of people working together towards a common aim.
Within a team, you’ll find a range of different people with different skills, experience, and talents.
Each person can give their attention and effort to the things that they are good at, and by working alongside others on tasks outside their current repertoire, they can expand their skillset.
Software engineering teams meet regularly throughout the duration of a project.

Working in a team 
- promotes creativity.
	Collaborating with others gives you the opportunity to discuss ideas and challenge one another’s thinking about a subject.
- empowering: positive attitudes and behaviors can impact the rest of the team and create positive results.
Good teamwork encourages creativity, shares knowledge, and results in better quality code.
Working alongside others can encourage creativity and enable you to take advantage of each person’s strengths while also allowing them to gain knowledge and skills from other members of the team.
When working as part of a team, software engineers are more likely to adhere to corporate coding standards and regularly document their code.
The additional accountability that teamwork creates results in better quality code, fewer bugs, and more maintainable code.
From a software engineer’s point of view, working as a team can reduce stress because there’s always someone to turn to and get help from.
And having someone to discuss problems with can help you to increase your understanding and resolve more issues by yourself.
By working in a team, each member has a greater idea of the bigger picture, resulting in a more coherent overall solution.


Things to do to work well as a team 
	Each member needs to trust and respect the other members of the team. This generally comes with time, but depends on all of the members contributing equitably.
	Defining and agreeing on goals for a project is essential so that the whole team knows what they are working towards.
	And you also need to define and agree on roles to avoid any duplication of effort or missed tasks.
	Working with each members strengths is important to make the most of the talent within your team, as is celebrating success and analyzing problems.
	Communication is vital in a team environment.

teamwork in software engineering
start projects = kick-off meeting where they plan how they will complete the project, assign tasks, and agree on goals.
Throughout the lifetime of a project, you’re likely to have whole team and/or sub team meetings to review progress and plans.
Design and code reviews can be requested at the team level and undertaken by whoever has availability at that point in time.
Team members might present walkthroughs of their sections of responsibility to the rest of team so that the whole team has oversight of all parts of the project.
key team members will likely present walkthroughs to stakeholders at various times during the project.
When a project is complete, retrospective meetings may be held to review what went well and what could be improved in future projects.
You may have a mentor who may or may not be in your current project team or be asked to be a mentor.
Sometimes team mentoring is used so everyone can learn from each other.
Some groups also have teams working on internal projects such as defining code standards, maintaining or updating legacy cross-project code, or reviewing potential new software for usefulness to the team.

Some organizations that follow Agile development methodologies may call a team a squad.
Typically, a squad is a small team of up to 10 developers.
It is likely to consist of:
- A squad leader who acts as the anchor developer and coach for the squad.
- a few software engineers who develop and implement the product features and test cases.
- (optiona )one or two user experience developers or designers.
In some squads the developers may work together in pairs to practice pair programming.
##### Insiders' Viewpoint : Teams in Software Engineering
In this video, we will hear from experts discussing how teamwork is important in software development, and how teams work together.
Yeah, so teamwork is very, very important in the world of software development.
As a software engineer, you're not just going to be sitting at your desk coding all day.
One of the most important aspects of working on a team or on an engineering team is communication,
and knowing how to collaborate and speak with your team members about the code you've written,
especially if you're going to a UX designer, and say, Hey, here's what I can do.
And your spec is a bit off.
Can we massage your your specs a bit just so we can meet the code coding requirements.
Incredibly important, I while I think it's possible for a single person to engineer and
deploy and run software, I, I think doing it as a team is both more impactful and gets
you more potential to do bigger and greater things, I think it's also just a more fulfilling
process, when you're when you're, you're building something with a group of individuals, I think,
you know, with without the support structure, it's hard to build something and support it
and maintain it just by yourself.
So teamwork, to me, is essential, because we're talking to each other all day.
And we're not only talking to our tech leads or senior engineer, we're talking to product
managers, we're talking to UX designers, we're talking to business analysts, we're talking
to data analysts, and so on and so forth.
You have the support system, you have diversity of opinions and perspectives in terms of how
you go about building it, it's more satisfying, you kind of can take larger risks, because
you're, you're in it together, and you're there to support each other, I think the celebration
of of a job well done is is a lot more, you know, it's a lot more fulfilling when you're
when you're doing that with someone else.
But I think it just gives you both kind of a larger range of scope and a larger sort
of risk portfolio, if you will, and you're able to, I think just, you know, get a lot
more done a lot more checks and balances and really gives you you know, less likely, there's
a less likely chance that you're gonna miss something, or you're gonna make a mistake,
there's a lot of a lot of support there.
And so every project I've worked on has had at least three other people that I have needed
to communicate with and support to be a reliable resource for them to go to them for questions.
Like I always have to be talking to somebody about something.
So teamwork is crucial.
Like, you can't, you can't work in an isolated silo forever, at some point, you have to talk
to someone else.
Building a project product takes a lot of people, a lot of us come together to make
a whole and to get the product shipped to production so our users can use it.
And so teamwork is imperative.
: Added to Selection. Press [CTRL + S] to save as a note
​

##### Pair programming
=Agile development technique where two developers work alongside each other.
builds technical and soft skills, results in better quality code and solutions, and increases overall efficiency.
Pair programming is an extension of teamwork where two developers work side-by-side at one computer. They can either be physically at the same computer or work virtually via video link or shared screens. The former is the preferred option, but virtual pair programming can also be productive.
Pair programming is a type of Agile development where two developers can plan and discuss their ideas continually as they create a solution, generally resulting in a better end product.
###### styles of pair programming: 
Driver/navigator stye (most common)= one developer is the driver, typing in the code, and the other is the navigator, reviewing the code as it’s written and giving directions where to go next.
	The navigator also keeps an eye on the bigger picture of the overall solution.
	important to regularly swap roles to keep both of the pair engaged across the whole task.
Ping-pong style = incorporates test-driven development. 
	For each task, one developer writes a failing test and then the second developer writes code to pass that test (the impementation). For each new task, they swap roles, so regularly changing
	The two developers work together at the end of each task refactoring the successful code to refine and improve it.
Strong style pair programming 
	good way for junior software engineers to learn from more experienced ones.
	The defining rule for this is that for an idea to go from your head to the computer, it must go through someone else’s hands.
	So, the more experienced of the pair is the navigator and the driver learns from witnessing their implementation and thought processes.
	For this to work well, the driver shouldn’t challenge any ideas until the full implementation is complete so as not to interrupt the flow of ideas from the navigator. 

###### benefits.
It’s a good way to share knowledge and skills from one developer to another or between the two and a great way for a new team member to get up to speed on a project.
As well as enhancing the technical skills of the pair, it’s also a good way of building soft skills such as communication and problem solving.
two sets of eyes on the code often results in fewer typos, logic errors, and bugs.
enables code reviews to be done on the fly.
While this doesn’t replace formal code reviews, it does enable another layer of review.
Having two people thinking about a problem can result in multiple initial ideas, but is likely to result in the optimal approach being chosen earlier in the process.
And although pair programming can take longer than individuals writing the same solutions, it’s likely to result in better code with less time spent reviewing, testing, and bug fixing.
###### challenges
Working in a pair requires long periods of focus which can be exhausting for the two programmers.
personal or other work commitments can impact the pair schedule.
Sometimes one of the pair can end up controlling the entire process, resulting in a more typist/programmer pairing which doesn’t benefit from any of the positives of pair programming.
And at other times, individual personalities may not work well together. 
When multiple sets of pair programmers are present, their discussions can result in a noisy environment for the other workers in the room.
##### Insiders' Viewpoint : Pair Programming
experiences with pair programming and about the benefits they associate with it.
At every job I've ever had, there have come times where you pair up with someone else, you get someone else sitting next to you at a computer, you're sitting next to them at their computer, you're looking at a problem together, you're thinking about it. Yes, I have actually, some of the benefits are definitely working with an engineer who might be more of a senior engineer, because they have a lot of insight. And they obviously have a lot of experience doing what you're probably trying to figure out how to do. And it's really great when it's someone who can both guide you but also kind of take take a step back and not take over at the same time. I think pair programming can can be very beneficial. I think. If you're when you're working with someone together, it's an opportunity to learn I think pair programming can be very great in circumstances where someone is new to a team. New to a programming language new to a set of tools, or a development environment that is new to them, sitting next to someone who's an expert, I think can both help you ramp up more quickly, it can help the the team itself, sort of understand where you are, in terms of your own knowledge and journey and help put you in a place to both succeed and utilize you in your skills as best as possible. It does help you get real time feedback, you don't necessarily have to wait for code to be sent out to be reviewed, and you can kind of, you know, brainstorm together in real time on the actual implementation of it. Ultimately, I try to keep in mind that the goal of pair programming is that everyone has inherent blind spots in the way that they think. And that the way that they approach a problem. And if you are talking to somebody else, they can point out what your blind spots are. And they're going to have different blind spots than you as well. So you can point out their blind spots. What do you think are the drawbacks and challenges of pair programming? I think that can be a con sometimes when you're working with another engineer and you're trying to pair program with someone who kind of like takes over and then doesn't allow you to do your part or to learn especially if they kind of like already know how to do something. So it's kind of like a double-edged sword. On the one hand, you want to get that practical experience of practice of pair programming and you want to get that experience from someone else. But at the same time, you want to make sure that you're learning. I personally find pair programming to be a little frustrating. Because the ways I go about solving problems can be very different than the ways other people go about solving problems. And it's not that I have some special, unique, wonderful technique, it's just that everyone's
brain works differently. And watching someone else go through their workflow of how to solve a problem, they're not clicking the exact same buttons that you are. And that can get very frustrating to me. It's like, why are you using your mouse because all those things, there's keystrokes or like, you could be doing this so much faster. And so I find it a challenge to do pair programming sometimes. You actually need calendar time. So you need to be able to dedicate time to sit together and work together and have an aligned schedule. You both you can either be physical, could do it virtually, but you need to make the time to do it. Pair programming, some can come with some overhead in terms of getting off the ground. So if you have a tight time crunch, competing priorities, maybe just not enough, there might be not enough time in the schedule to allow for it, that can be one of the cons. That it can while you can get long term, I think efficiency benefits from you know, built, did writing the code together, because then support in the future will be easier
because you have more people who know how the code was written and what the intent was. So there are definitely long term benefits. But there could be you know, some short term costs to it= trade offs 

#### Tools in Software Dev
##### Introducing App Dev Tools
Getting your Cloud App from the ideas stage to fully formed, written, and deployed is a long process, but there are many tools which will help you along the way.
A cloud application developer’s workbench includes:
Version Control, Libraries, and Frameworks.

###### Version control systems 
Version control systems keep track of what changes were made when and by whom and resolve any conflicts between changes.
When many developers are working on the same project, knowing what order changes were made, thereby creating a new version of the source code, becomes overridingly important.
can be useful even when you are the sole contributor on a project.
Properly used= a way to revert to an older version of your code if something goes wrong and gives you some basic information about how the code developed over time.

! Version control functionality is generally tied to the storage system you are using, which is why a code repository is recommended, even for beginners.

Git and GitHub are extremely popular for source code storage and management.
Git stores files in repositories where you can track changes, split code into different branches for more focused development, and then merge them back into the main body of code.
###### Libraries 
are collections of code, like standard programs and subroutines, that you can use within your code.
code library can supply you with the code for that so that you don’t have to spend the time and energy creating one from scratch.
Being able to reuse code in this way makes developing your app much quicker and easier.
Multiple code libraries can be integrated into your existing project.
As you discover a need for a specific function or feature, you can research an appropriate library.

You determine when to call the required method as needed. The control returns to the program flow once the subroutine is finished.
When you use a code library, you are in control.
Code libraries are generally used to solve a specific problem or add a specific feature set.

Either way, there are lots for you to choose from, so do your research.
Here are some examples of code libraries:
	jQuery is a JavaScript library that simplifies DOM manipulation.
	Email-validator is a small library that checks an email address is correctly constructed and valid.
	Apache Commons Proper is a repository of reusable Java components.

###### Frameworks 
provide a standard way to build and deploy applications.
~ skeleton that you can extend by adding your own code, providing a scaffold on which to build your apps.
The framework you intend to use must be determined early in your development planning and used right from the beginning.

New frameworks can’t be incorporated into an existing project.
Your chosen framework dictates the architecture of your program and controls the program flow.

The framework determines which subroutines and methods will be called when. When working with a framework, there is a specific structure that you must follow.
The framework calls on your code, rather than you calling on the framework.
Frameworks are less flexible than libraries, allowing you less control, but they do provide good standardization and can help you create efficient code.
To use an analogy, if you are a carpenter building a house, the framework is the frame that you add to – bricks on the outside, plasterboard on the inside, and so on. The frame acts as a guide for how the house is constructed.

Here are some examples of frameworks:
	AngularJS is a JavaScript-based framework for dynamic web applications.
	Vue.js is a JavaScript framework focused on the user interface.
	Django is a framework that uses Python for web development.

Frameworks define the workflow that you must follow, unlike libraries, which allow you to call functions as and when required.
When using a framework, it can sometimes feel like you, as a developer, are not in full control of the development process.
This sense of the framework and its predefined workflow controlling the development process is referred to as inversion of control.
Frameworks that have a lot of control are known as opinionated – they have opinions on how their workflow should be used and remove a lot of the decisions you would otherwise have to make about how code is written, the location of files, and even file names.
Frameworks often include their own libraries, which they call when needed.
Inversion of control allows you to create standardized apps, and takes away a lot of the tedious configuration work, so you can focus on the code for your app.
##### More App Dev Tools
tools which can help you get your app built and deployed:
	CI/CD, Build Tools, Packages, and Package Managers.

###### CI/CD 
refers to the practices of continuous integration and either continuous delivery or continuous deployment.
CI/CD is a best practice for devops teams enabling developers to deliver frequent changes reliably.
Implemented through a build-automation server, Continuous Integration (CI) ensures that all the code components work together smoothly.
A CI build environment enables you to integrate newly developed code frequently, at least every day, if not every hour, depending on how quickly the project changes.
Continuous delivery (CD) begins where CI ends. The CI process automatically builds and tests your code, then CD deploys all code changes in a build to a testing or staging environment.

###### build tool 
transforms your source code into the binaries needed for installation.
Build tools organize your source code, set compile flags, and manage dependencies.
They are most important in environments where there are many inter-connected projects, with multiple developers contributing to each project.
In these environments, it can be very difficult to keep track of what changes were made, in what order, what dependencies exist, and what needs to be incorporated in the next build, so automation is key to keeping everything running smoothly.
Build automation can automate a wide variety of tasks that developers do in their day-to-day activities like:
	Downloading dependencies.
	Compiling source code into binary code.
	Packaging that binary code.
	Running tests.
	And deployment to production systems.

You can initiate a build from the command line or from an IDE.

There are two categories of Build Tools widely in use:
	Build-automation utilities, which generate build artifacts like executables, by compiling and linking source code.
	Build-automation servers, which execute build-automation utilities on a scheduled or triggered basis.

Some examples of build tools are:
	Webpack – a module bundler for JavaScript.
	Babel – a JavaScript compiler.
	Web Assembly - a binary instruction format that runs in your browser.
###### Package managers 
Now that you have your app developed and tested, you’re ready to deploy.
The app needs to be simple and trouble-free for the user to install, so a commonly used technique is to collect all the necessary files and bundle them together into a package.
Packages are archive files that contain the app files, instructions for installation, and any metadata that you choose.
They have their own metadata too, including the package description, package version, and any dependencies, like other packages that need to be installed beforehand.
Once you have bundled your app into a package, you can use a package manager to distribute it.

Package managers take care of the tasks of finding, installing, maintaining or uninstalling. software packages at the user's request.

Package management systems:
	Coordinate with file archivers to extract package archives.
	Verify checksums and digital certificates to ensure the integrity and authenticity of the package.
	Locate, download, install, or update existing software from a software repository.
	Manage dependencies to ensure a package is installed with all packages it requires.

Some commonly used package managers for each of the major platforms are listed here:
	On Linux - Debian Package Management System (DPKG). Red Hat Package Manager (RPM).
	On Windows - Chocolatey.
	On Android - Package Manager.
	On MacOS - Homebrew and MacPorts.
	
Any libraries or utility code that is developed as part of the application is managed with the cloud application package managers.
Here are some examples of package managers for popular languages:
	For Node.js/ Javascript - npm.
	For Java - Gradle and Maven.
	For Ruby - RubyGems.
	For Python - Pip and Conda.
##### Intro to Software Stacks
- [ ] describe software stack terminology, 
- [ ] identify some commonly used software stacks,
- [ ] list the benefits and challenges of different software stacks.

###### software stack
= a combination of technologies that includes software and programming languages. 

Software stacks are a combination of technologies for creating applications and solutions.
Software stacks can range from simple three-layered systems to many layers.
There are numerous types of software stacks for different developers and environments.
The biggest advantage of the MEAN stack is that all of the parts use JavaScript, so developers only need to know a single language.
And, the LAMP stack on Linux works well for relational data. 

Developers use a software stack to create applications and solutions such as web and mobile apps. The set of individual technologies is stacked in a hierarchy and work together to support the execution of an application.  The higher levels in the stack provide tasks or services for the user and the lower levels interact with the computer hardware.

Software stacks typically include:
	Front-end technologies such as programming languages, frameworks, and user interface tools.
	And back-end technologies such as programming languages, frameworks, web servers, app servers, operating systems, messaging applications, and databases.

You might hear the term technology stack used in place of software stack. 
However, a technology stack is a broader term that includes hardware and infrastructure like virtual machines, containers, storage, and load balancers, as well as the software stack.

The simplest implementation of a software stack consists of 
	a presentation layer,
	a business logic layer,
	a data layer. 
However, more complex applications use more complex stacks, which could include software for virtualization, scheduling and orchestration, runtime environments, database connectivity, networking, and security.

The software and services that make up a stack can be from a variety of sources: from internal resources, to third party providers, to cloud providers.
There’s no formal definition of the structure of a stack, the only rule being that the software and services included must support an application’s development, functionality, or deployment.
When you’re using a software stack, you don’t have to use all of the available layers, you only need to use those which are relevant to your solution.

There are many different examples of software stacks,
	Python-Django stack, uses the popular Python programming language alongside the Django web framework. 
		This combination is all open source and commonly used for large-scale, fast-changing web applications.
	Ruby on Rails stack, uses the Ruby programming language with a server-side web application framework. 
		 is great with JSON or XML for data transfer and HTML, CSS, and JavaScript for front-end development.
	ASP.NET stack includes Microsoft technologies such as the ASP.NET MVC framework, the IIS web server, SQL Server, and Azure.
	LAMP stack runs on the Linux operating system.
		 It uses the Apache HTTP or Web server, MySQL databases, and the PHP programming language. LAMP is an example of an early incarnation of a software stack designed for building websites and cloud applications. All its constituent parts are open source and loosely coupled, so it’s easy to swap different options into the stack. For example, you could choose to use PostgreSQL instead of MySQL for your database server, changing the LAMP stack to be the LAPP stack. Similarly, you could use the Python programming language instead of PHP.
	MEAN stack uses a MongoDB database with an Express.js web application server framework, the Angular.js framework for front-end JavaScript development, and the Node.js platform for server-side scripting.
		The MEAN software and services are platform agnostic, free, and open source.
		There are other stacks related to the MEAN stack, including:
			The MERN stack which replaces Angular.js with React, and is a flexible and high-performing framework for developing front-ends.
	MEVN stack which replaces Angular.js with Vue.js. Vue is a lighter-weight JavaScript framework with less capabilities, but it can provide better performance than Angular.js.

###### advantages and disadvantages of three different software stacks: MEAN, MEVN, and LAMP.
MEAN is a free and open-source JavaScript software stack used for building web applications. 
	Advantage
		Biggest = all of the parts use JavaScript, so developers only need to know a single language.
		open source which means the cost is lucrative to businesses and there is a lot of documentation and re-usable code for developers to use. 
		Development can happen quickly because Node.js has a huge collection of free, reusable module libraries.
	Disadvantage = not be well-suited for large-scale applications.
		When using Express.js, the business logic often resides on the server preventing the reuse of some services like batching operations. And MongoDB is great for unstructured data, but it doesn’t provide the same level of functionality as a relational database.
MEVN ( MEAN but it uses Vue.js instead of Angular.js for user interfaces)
	similar advantages,  software and services also are open source 
		but Vue.js is a much newer technology and doesn't have as many reusable libraries as Angular.js.
LAMP 
	 advantage
		 software and services also are open source meaning there are lots of reusable chunks of code available to the developers.
		 LAMP is one of the oldest software stacks it’s easy to find support and reusable solutions. 
	 disadvantage 
		 because the Linux operating system is an integral part of the stack, it isn’t as flexible as MEAN and MEVN which are platform agnostic. MySQL is a relational database, so the stack cannot take advantage of unstructured data. 
		 the back-end runs on PHP, Perl, or Python, whereas the front-end uses JavaScript and HTML, making it harder for developers to switch back and forth than the MEAN and MEVN stacks which use JavaScript throughout.


​

##### Hands-on Lab: Getting Started with an IDE
https://author-ide.skills.network/render?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJtZF9pbnN0cnVjdGlvbnNfdXJsIjoiaHR0cHM6Ly9jZi1jb3Vyc2VzLWRhdGEuczMudXMuY2xvdWQtb2JqZWN0LXN0b3JhZ2UuYXBwZG9tYWluLmNsb3VkL0lCTS1DUzAxMzFFTi1Ta2lsbHNOZXR3b3JrL2xhYnMvTW9kdWxlJTIwMi9HZXR0aW5nJTIwc3RhcnRlZCUyMHdpdGglMjBJREUvR2V0dGluZ19TdGFydGVkX3dpdGhfYW5fSURFLm1kIiwidG9vbF90eXBlIjoidGhlaWEiLCJhdGxhc19maWxlX2lkIjoyMTcxMSwiYWRtaW4iOmZhbHNlLCJpYXQiOjE3MzAxMzgxNzN9.6T8knQtQUyoJ83mZ9QdhIVQ-gujY_sHhNl-KBqXHdK8
##### Insiders' Viewpoint: Tools and Technologies
#### Summary and Quizzes
##### Summary
### Module 3 
#### Learning Objectives
#####  Learning Objectives
This module introduces you to the basics of programming. In the first lesson, you will learn about the different categories of programming languages and the scenarios to which each is suited. You’ll also learn how to plan and organize your code effectively. In lesson 2 you will explore basic programming logic and investigate programming concepts such as identifiers, functions, and objects. Finally, in the hands-on lab, you’ll learn how to write simple Python code.
- [ ] Identify interpreted programming languages and compiled programming languages.
- [ ] Compare interpreted and compiled programming languages.
- [ ] Describe query languages and assembly languages.
- [ ] Define the two main methods of organizing and planning code and describe the advantages of each.
- [ ] Design simple flowcharts.
- [ ] List the differences between branching and looping.
- [ ] Describe the purpose and use of identifiers and containers.
- [ ] Describe the purpose and use of functions and objects.
- [ ] Write and run simple Python code that uses variables, constants, arrays, loops, and conditional logic.

#### Programming Languages and Organization
##### Interpreted and Compiled Programming Languages
- [ ] Identify interpreted programming languages,
- [ ] identify compiled programming languages.

What are programming languages?
Programming languages help us tell computers what to do.
Computers don’t use human language; they use machine code.
Machines understand binary code, that is 1s and 0s.
So, to make communicating with computers easier, we have human-readable programming languages.
Two common categories for programming languages are:
Interpreted
and compiled.
These are broad categories, and there are many programming languages that are classified
under compiled languages and interpreted languages.
The purpose of the project helps a developer determine which programming language is best.
Interpreted language is also commonly referred to as scripted or scripting language.
Programs written in interpreted or scripted language, like Python and HTML, run through
the programming interpreter on your computer’s operating system or in your web browser.
Remember that programming languages are in human-readable code,
so, the interpreter takes the human-readable scripted code and then translates it into
machine code, enabling the computer to complete the requested task.
As computers and web pages have changed and advanced, some interpreted programming languages
are outdated, and they are not as useful or relevant
Some other languages are more versatile and easier to learn, which means they are preferred
over other scripting languages and used more often.
All interpreted programming languages need an interpreter to translate the source code.
Translators are built into your web browser or they require a program on your computer
to translate the code.
Several different interpreted programming languages exist.
Some examples of common interpreted programming language types are:
• JavaScript, a simpler scripting language that runs through the web browser interpreter
• Python, a language that is popular because it is easy to learn and use for developers
• Lua, a general purpose, lightweight game scripting language that is easy to learn and
use
• HTML, a markup language used for formatting web pages
Another category of programming languages is the compiled programming languages.
Compiled programs are applications and programs, like your music app or your operating system,
that you run on your computer or device.
The programs are packaged --or compiled-- into one executable file.
They are usually larger programs.
Compiled programs are used to help solve more challenging problems, like interpreting source
code.
Compiled programming languages are often referred to more simply as programming languages.
A compiler program creates a program file, which runs the software.
Simply put: It piles the code into one file that runs when you double-click on the app
on your device.
The program runs faster and it can be done repeatedly.
The source code is converted from the programming language to machine code.
Then it is compiled into one executable file.
Finally, the program runs when you select the icon or file on your device.
Some examples of compiled programming languages are:
C and its variations C++ and C#, which are used in many operating systems, like Microsoft
Windows, Apple’s macOS, and the open-source operating system Linux.
Java is another compiled programming language.
It shouldn’t be confused with the interpreted language JavaScript.
The Android OS is written in Java because it works well across computing platforms.
Let’s look at this process:
When you update to a new version of your operating system, like Microsoft Windows, your device
might download an installation program.
That program is made up of many files.
The files are written in a compiled programming language.
These files give instructions to your device in machine code.
The compiled program is running on your device.
A compiled program that you commonly use is your device’s operating system, such as
Linux, Microsoft Windows, Apple’s macOS, or Android.
Your operating system is written in a compiled programming language, like C, C++, C#, or
Java.
In this video, you learned that:
Interpreted programming languages run scripts that are repetitive and need to be run often.
Interpreted programming languages are more versatile and can be used across platforms
as long as there is the correct interpreter.
Some examples of interpreted programming languages are JavaScript, Python, and HTML.
Compiled programming languages are for more complex programs that complete larger tasks.
Compiled programming languages are used for creating executable files that can run directly
from your device.
And some examples of compiled programming languages are C and Java.
​
##### Welcome to comparing compiled and interpreted programming languages.
After watching this video, you will be able compare interpreted and
compiled programming languages and discuss interpreted and
compiled programming languages.
How do developers choose a programming language?
Developers choose which programming language is best to use depending on what
they have the most experience with and what they trust, what is best for
their users, and what is the most efficient to use.
What are interpreted and compiled programming languages?
Interpreted programming languages are used to create a scripted source code for
smaller tasks.
The source code goes through an interpreter.
The interpreter is built into the operating system on a computer or
on a web browser.
Compiled programming languages are used to create files.
The files are executable files.
They are then grouped in programs that you can run on a computer or device.
Interpreted programming languages are also called script code or
scripting, because they are used to automate tasks.
Interpreter programs read and
execute the source code line by line like someone would read a script.
Each time the program runs,
the source code needs to be executed to receive the desired output, and
source code written in one of the interpreted programming languages runs on
almost any operating system with the right interpreter.
For example, imagine you have a client requesting information about webpage
views for last month.
Which type of programming language would be the most appropriate and
efficient to create a program for this task?
You would use one of the interpreted programming languages to write code for
a script.
The script would retrieve the webpage views data and
then put it into a table for the client to read.
Compiled programming languages are also called programming languages for short.
They are used for more complex programs that complete larger tasks,
like running a spreadsheet program on your computer.
A compiled programming language is used to write a larger program,
usually installed on your device as an executable file.
Writing code in a compiled language does take longer, but
the payoff is that the programs code runs faster,
because compiled programs are installed on the device.
And once the program is coded,
the compiled program is grouped into one downloadable file.
Remember that client who wanted information about webpage views?
Now, they want a spreadsheet program to view and manage the data.
A programmer could use the C programming language to create a compiled
program like Microsoft Excel.
So what are the major differences between interpreted programming languages and
compiled programming languages?
First, there's interpreted programming.
These programs are available across multiple platforms or in the cloud.
The scripting languages are easier to learn and use, and
they're better for websites because they tackle smaller, repeated processes.
Then there's compiled programming.
These programs are available to users with the same operating system coded in
the same language.
However, compiled programming languages are more difficult to learn and use,
because they are larger programs with more parts, and they're better for
larger tasks, like running the operating system on your computer.
To better understand more of the similarities and
differences of programming languages, let's take a look at some examples.
A few of the most common programming languages are C, C++ and C#.
C is a compiled programming language.
C is the original language, and C++ and C# are variations.
C and its variations are case-sensitive languages.
The C programming language is the basis for Windows and
other common operating systems, and it takes more time to learn and
use for coding but requires less memory and the code runs faster.
Another common programming language is Java.
It is a compiled programming language.
It is also a case-sensitive, object-oriented programming language.
The Java virtual machine or JVM is required to run the code written in Java.
It is the primary programming language for some operating systems,
like the Android OS.
And a benefit of Java is that it is a cross-platform language,
which means it runs the same code on macOS, Windows, and Linux.
Python is an example of an interpreted programming language.
It is also referred to as a scripting language.
Python is a popular general-use, case-sensitive programming language.
It is used with Windows, macOS, and Linux operating systems, and with
server-side web app code, and it requires the Python engine to interpret code.
JavaScript is another interpreted programming language.
It is a scripting language that runs on the client side in web browsers.
JavaScript is case sensitive.
Simple scripts are run with HTML.
Complex scripts are run in separate files.
And while it sounds similar, it shouldn't be confused with Java,
the compiled programming language.
Another example of a common programming language is HTML.
It is an interpreted programming language.
HTML stands for Hypertext Markup Language.
HTML is mostly case insensitive with some exceptions, and
it uses tags to format webpages on client-side web browsers.
In this video,
you learned that interpreted programming languages create source code that runs
through an interpreter in your device's operating system or on your web browser.
Compiled programming languages create executable files that are grouped in
programs on your device.
Compiled programming languages like C and Java are used to write larger programs,
like operating systems and other executable files.
And interpreted programming languages like Python and HTML are used to write
code that can complete repetitive tasks within a web browser or a computer.
[MUSIC]
​

##### Welcome to “Query and Assembly Programming Languages.”
After watching this video, you will be able to:
Compare high-level and low-level programming languages.
Describe query languages,
and describe assembly languages.
Let’s explore query and assembly programming languages.
But first, we need to categorize programming languages
into two levels – high-level and low-level.
A high-level programming language is
more sophisticated and
uses the common English language to make its code more understandable
and to increase the speed of coding and debugging programs.
Examples of high-level programming languages include query languages
such as Structured Query Language (or SQL), structured programming languages such as Pascal,
and object-oriented programming languages such as Python.
In contrast, a low-level programming language
uses a set of symbols to represent machine code.
And examples of low-level programming languages include assembly languages
such as ARM, MIPS, and X86.
A query is a request for information from a database.
The database handles the query and searches its tables for the information requested
and returns the results to the querying entity.
When querying a database, it is important that both the user application making the query
and the database handling the query are speaking the same language.
In programming terms, writing a query means using predefined
and understandable instructions to make the request to a database.
This is achieved using programmatic code and this is what we refer to as a query language.
A query language may also be referred to as a database query language.
By far the most prevalent query language for database queries and database management is SQL.
However, there are other query languages available
such as AQL, CQL, Datalog, and DMX.
In addition to SQL databases,
there is another type of database called NoSQL, which stands for Not Only SQL.
The key difference between these two types of databases is their data structures.
While SQL databases are relational
and use structured, predefined, schemas,
NoSQL databases are non-relational in nature
and have dynamic schemas for unstructured data.
A query language is predominantly used to request data from a database
or to create, read, update, and delete data in a database. You will likely see the term
CRUD used to refer to these last four key database operations.
Typically, a user enters a command to either make a query or perform a CRUD operation using syntax
that is understandable to the database management system hosting the database.
And a database typically consists of structured tables made up
of multiple rows and columns of data.
When a user performs a query,
the database retrieves the data from the relevant rows and columns in the table and
arranges it into some sort of order,
ready to be returned and presented in the query results.
Database queries are either
a select command,
or an action command, such as CREATE, INSERT, UPDATE, or a mixture of both.
The term “statement” is more commonly used to describe these commands.
Select queries request data from a database,
whereas action queries manipulate data in a database.
Query statements can also be used to perform other administrative functions
such as creating users and modifying permissions.
This table lists some of the most common SQL query statements.
Here are some simple syntax examples of common SQL statements.
As mentioned earlier, assembly languages are less sophisticated than query languages,
structured programming languages, and object-oriented programming languages.
As an assembly language uses a simple set of symbols to represent the 0s and 1s
of machine code, it is categorized as a low-level programming language.
Assembly languages are closely tied to the processor architecture from hardware manufacturers
and therefore, each CPU type will typically have its own assembly language.
For this reason, there are a large number of assembly languages in use today,
which vary among hardware manufacturers.
Assembly languages use a simple readable format for their statements,
and they are entered one line at a time,
with one statement per line.
Assembly language statements use the standard format shown here.
In this syntax all fields in curly brackets { } are optional,
and the statement has two main parts.
The first part is the instruction (or the mnemonic),
and the second part includes the parameters (or the operands).
There may also be optional useful comments added on the end of the statement.
One other key difference with assembly languages
is that they are translated using an assembler instead of a compiler or interpreter,
and one statement translates into just one machine code instruction,
as opposed to high-level languages where one statement can be
translated into multiple machine code instructions.
Assemblers translate assembly language into machine code using mnemonics
such as Input (INP), Output (OUT), Load (LDA), Store (STA), and Add (ADD).
The statements consist of opcodes that tell the processor what to do with the data,
and operands that tell the processor where to find the data.
In this video, you learned that:
Query languages, structured programming languages,
and object-oriented programming languages are categorized as high-level programming languages.
Assembly languages are categorized as low-level programming languages.
A query language is predominantly used to request
data from a database or to manipulate data in a database.
The most prevalent query language for database queries and database
management is Structured Query Language (SQL).
Select queries request data from a database,
whereas action queries manipulate data in a database.
You also learned that:
Assembly languages use a simple set of symbols to represent the 0s and 1s of machine code.
Assembly languages are closely tied
to the processor architecture from hardware manufacturers.
Assembly languages are translated using an assembler instead of a compiler or interpreter.
And assembly language instructions
have a one-to-one association with their machine code counterpart.
​

##### Welcome to Understanding Code Organization Methods.
After watching this video, you will be able to:
Explain why code organization methods are important when programming.
Define the different code organization methods
and identify the benefits of using code organization methods.
Organizing is very important when it comes to reading, maintaining, and configuring code.
Well-planned-out software design, usually using one of several methods, helps programmers
write cleaner and more reliable code.
Planning out code in a visual format helps improve the code base once it is written and
reduces the chance of bugs and errors throughout the lifespan of a project.
Organizing code before programming has a positive impact on the quality of the program and helps
provide a consistent and logical format to use while coding.
There are two main methods of organizing code: flowcharts and pseudocode.
The main difference between pseudocode and a flowchart is that the former is a basic,
high-level description of an algorithm.
An algorithm is a step-by-step sequence of solving a given problem.
A flowchart is a pictorial representation of an algorithm showing the steps as boxes
of various shapes and colors connected by arrows that indicate their order.
Flowcharts are used in designing or documenting a process or program.
Pseudocode provides a beneficial bridge to the project code because it closely follows
the logic that the code will.
Pseudocode also helps programmers share ideas without spending too much time creating code,
and it provides a structure that is not dependent on any one programming language.
Flowcharts are especially beneficial for smaller concepts and problems, while pseudocode is
more efficient for larger programming projects.
And flowcharts provide an easy method of communication about the logic and offer a good starting
point for the project because they are easier to create than pseudocode in the beginning
stages.
A flowchart is the graphical or pictorial representation of an algorithm using different
symbols, shapes, and arrows in different sizes and colors to demonstrate a process or a program.
The main purpose of using a flowchart is to analyze different methods of solving a problem
or completing a process.
Several standard symbols are applied in a flowchart, and you can easily highlight certain
elements and the relationships between each part in the process.
Some traditional flowchart shapes used for programming concepts are:
Start/End (a capsule),
Process (a rectangle),
Decision (a diamond),
Data (a parallelogram),
And Connecters (as arrows).
A simple flowchart to represent how to add two numbers is easy to create.
The procedure starts with the capsule, and has a connector, or arrow, progressing to
the next step, the data input (the parallelogram), in this case, input n1 and input n2.
Then, another connector, or arrow, goes to the process (the rectangle) of adding the
two inputs, Sum = n1 + n2.
Another connector, or arrow, moves to the data (the parallelogram) showing the results,
in this case, Print Sum.
The last connector, or arrow, moves to the end of the process, the end capsule.
Flowchart software is an application that provides various functionalities to create
flowcharts by providing the ability to drag shapes into the desired order using an easy-to-use
editor.
Flowchart software also provides team collaboration for creating flowcharts.
Some of the well-known flowchart software programs include:
Microsoft Visio,
Lucidchart,
Draw.io,
And DrawAnywhere.
Pseudocode is an informal type of programming description that does not require any strict
programming language syntax or underlying technology considerations.
System designers write pseudocode to ensure that programmers understand a software project's
requirements and align code accordingly.
Pseudocode is used for creating an outline or a rough draft of a program that summarizes
a program’s flow but excludes underlying details.
Pseudocode acts as the bridge between the programmer’s brain and the computer’s
code executor that provides the ability to plan instructions that follow a logical pattern,
without including all the technical details.
Pseudocode is a great way of getting started with software programming as a beginner without
worrying about coding syntax.
Pseudocode helps both programmers and non-programmers agree about the program’s goal and the basics
of how the task should be done.
Here’s one example of pseudocode written to check if the user entered an odd or even
number:
The next example displays the pseudocode written in C++:
There are many advantages of using pseudocode over flowcharts.
The main benefit of pseudocode is that it’s simple and explains exactly what each line
of an application should do.
The coder can focus more on logic than on program language syntax.
Removing the distractions of coding when using pseudocode makes the code development stage
easier.
Words and phrases in pseudocode represent lines of basic computer operations that simplify
translation from the pseudocode algorithm to the specific programming language.
Pseudocode allows programmers working in different computer languages to interact with each other.
Pseudocode can be reviewed by different development groups easier than real code.
Pseudocode is easier for non-programmers to read and enables quick and easy translation
to any computer language.
Writing pseudocode is more concise and easier to modify, so changes to the design can be
easily incorporated.
And lastly, unlike some flowcharts, pseudocode is usually less than one page.
In this video, you learned that:
Organizing and planning out software design enables programmers to write cleaner and more
reliable code, and organized code is very important from a readability, maintainability,
and scalability standpoint.
Two main methods of organizing and planning software code are by developing flowcharts
or writing pseudocode.
A flowchart is a pictorial representation of an algorithm showing the steps as boxes
of various kinds connected by arrows that indicate their order.
And the main goal of pseudocode is to explain exactly what each line of a program should
do, making the code construction phase easier for the programmer.
​

##### Hands-on Lab : Hello World in 11 Programming Languages
##### Welcome to Insiders’ Viewpoints: Types of Languages.
In this video, we will hear from experts discussing if they prefer developing in compiled or interpreted
programming languages.
most of the time, it doesn't really matter.
It just comes down to personal preference, like what are you going to get moving on the
fastest.
there are certain situations where it will make a difference, if you're compiling ahead
of time versus interpreting on the fly, if you're trying to eke out, like very small,
incremental performance benefits,
I prefer compiled code or compiled language that's compiled language just because I have
a more of a guarantee that it will well maybe not necessarily work, but will do what I
thought it will do.
And at least we'll deploy properly.
When when when being rolled out.
but usually no, it doesn't, doesn't make that much of a difference to either the development
process or the like deployment and use process.
There.
They, they definitely have advantages and disadvantages to each of them.
But most of the time, doesn't make that much of a difference to what I'm doing.
I think, interpreted languages can you know, there's a lot of like flexibility there.
And often you can do more creative things.
And then you know, the compiler, it's sort of stops, the buck stops with the compiler,
and you can't really avoid compiler errors with the compiled language with interpreted
there's more interesting runtime possibilities there.
So I think it really depends on what environment you're developing for, or what your your risk
factor is, when it comes to being okay with, with potentially buggy code being out in the
wild.
What do you think are the benefits of object-oriented programming over procedural programming?
Anything can be an object.
And object-oriented design puts hierarchies and patterns onto those things.
And that structure can make it easy to keep designs in mind.
And keep in mind how the different objects interact with each other.
It's also very easy in object-oriented programming to paint yourself into a wall where you have
put too much structure around everything.
And you now have this like explosion of useless boilerplate code.
So there's a bit of a, not catch 22.
But just a balance that you need to find in between how much structure should your thing
have?
How much flexibility should it have?
And how much should your intentions be imposed on that design and the way that people interact
I think procedural programming can be, you know, feels more mathematical and more sort
of, like pure engineering, in some sense.
And I think that that also can lend itself well to someone who is really looking to not
just build software, but really wants to sort of feel like they're engineering the code,
in some sense.
It can feel like you're, you're kind of like, in the machine if you will.
So, I know that's a weird answer.
But it's, it's I think it doesn't, you know, depending on how your brain works to one can
lend itself more easily than the other.
So, but I love I think it's worth trying them both out.
if you get super object-oriented, you can get a little to a little too prescriptive
with the designs, I think.
So that's just whenever you're using objects, it's just a thing to keep in mind that you
can go, you can go too far with it.
But where that line of too far is kind of depends on exactly what it is that you're
building, sometimes there, sometimes the sky's the limit, just regulate everything.
And sometimes the amount of flexibility that you require actually does mean that you can't
really have an object of any sorts.
Most of those situations should be pretty weird, those would be on the extremes.
But most of the time, a few simple objects will do a lot of good, no matter what the
rest of your system looks like.
Yeah, I think object-oriented programming to me is, for me, personally, I think it does
lend itself well to like real-world mappings and data models.
And, you know, the sort of classic examples of you might, in your first object-oriented
software, demo, build something like a library that has books, and it has a checkout.
So, like you get there's physical objects that the way you learn it is very much sort
of you think about the software as something real worlds that helps you make the jump from
building something physical with your hands to building something with, with bits and
bytes.
​

##### Activity: Programming Logic and Organizational Methods

##### Practice Assignment
#### Programming Logic and Concepts
##### Welcome to Branching and Looping Programming Logic.
After watching this video, you will be able to:
Describe the two types of programming logic
Define Boolean expressions and variables
and list the differences between branching and looping.
There are two major types of programming logic: branching and looping. Both types use Boolean
expressions and variables:
A Boolean expression is a type of programming statement with only two values, either "true"
or "false."
And variables have assigned values that are passed into a function or subroutine within
a more extensive program.
Computers use Boolean logic to make decisions. The computer takes one action if a Boolean
expression is true and a different action if the expression is false.
Typically, a program consists of instructions that tell the computer what to do and data that
the program uses when it is running. A variable has a value that can change, depending on
conditions or information passed to the program. Boolean logic, along with variables, form
the basis of programming.
Branching logic is where a computer program makes a decision following a different set
of instructions, depending on whether certain conditions are met during the program's execution.
Each possible code pathway creates another branch. The branch of code that runs depends
on the values assigned to the parameters of the branching procedure. There is no limit
to the number of branches to implement complex logic.
The values of these parameters may be input by the user or generated by the output from
a previous procedure.
Branching contains constructs that occur and are processed to determine the path a program
takes when running.
Branching statements (also known as constructs) allow the execution flow to jump to a different
part of the program. The common branching statements used within other control structures
include:
if,
if-then-else,
Switch,
and GoTo.
The if statement is a decision-making construct that guides a program to make decisions based
on specified criteria. The if statement executes one code set when a specific condition is
met (TRUE) or another code set if the condition is not met (FALSE).
The if-then-else is a conditional construct that executes its substatement, which follows
the “then” keyword. This only occurs if the provided condition is true.
The if-else statement extends the “if” statement by specifying an action if the
“if” (true/false expression) is false. With the if-else statement, the program will
execute either the true code block or the false code block, so something is always performed
with an if-else statement.
In computer programming languages, a switch statement is a type of selection control
mechanism used to allow the value of a variable or expression to change the control flow of
program execution via search and map.
GoTo is a statement found in many computer programming languages that performs a one-way
transfer of control to another line of code. In contrast, a function call typically returns
control.
Now, let’s look at the logic of looping programming. A loop is a sequence of instructions
that continually repeats until reaching a specific condition. Typically, a particular
process is performed, such as retrieving and changing data, and then some conditions are
checked, such as whether a counter has reached a prescribed number. If it has not, the next
instruction in the sequence is to return to the first instruction in the series and repeat
the sequence. If the condition is reached, the next instruction "falls through" to the
next sequential instruction or branches outside the loop. A loop is a fundamental programming
idea commonly used in writing programs.
There are three basic loop statements:
While
For
And Do-while.
In a While loop, a condition is evaluated before processing the body of the loop. If
a condition is true then and only then the body of a loop is executed.
In a For loop, the initial value is performed only once, then the condition tests and compares
the counter to a fixed value after each iteration, stopping the For loop when false is returned.
In a Do-while loop, the condition is always executed after the body of a loop. It is also
called an exit-controlled loop.
In this video, you learned that:
There are two major types of programming logic: branching and looping. Both types of logic
use Boolean expressions and variables.
Boolean expressions have only two possible values, either true or false, and variables
have assigned values that are passed into a function or subroutine within a more extensive
program. Variables have values that can change, depending on conditions or information passed
to the program.
And branching is deciding what actions to take, while looping is deciding how many times
to perform a certain action.
​

##### Welcome to Introduction to Programming Concepts – Part 1.
After watching this video, you will be able to:
Describe the purpose and use of identifiers in programming.
And Describe the purpose and use of containers in programming.
To fully understand software programming,
there are some fundamental programming concepts you need to know first.
The first concepts you will look at are identifiers.
Software developers use an identifier to reference a program component
such as a stored value, a method, an interface, or a class, by assigning a custom-named label to it.
If the identifier stores data, then the data values in the program can be one of two types:
either a constant, or a variable.
A constant is a data item whose value does not change within a program.
This could be a numerical constant such as the mathematical value of Pi,
or it could be a text string that remains constant such as a player’s name within a game.
Constants are also referred to as ‘named constants.’
You assign a value to a constant when you define it.
For example, you might want it to refer to a numerical value within your program such as Pi,
or a cost price, or a rate of tax, and then, rather than repeatedly retyping
the same numerical value, you can just declare a constant for that value instead,
and name it something meaningful like ‘pi_value’, or ‘cost_price’, or ‘tax_rate’.
There are a couple of major benefits to using constants in your programs;
one is for ease of readability in your code,
and the other is that if the specified value changes in the future,
you only need to change it once on the constant,
rather than finding every instance of that numerical value within your code and changing it.
The other type of identifier used in programming is a variable.
As the name suggests, this kind of identifier is not constant;
its value can change during the program’s execution,
such as a user entering their age in an application
or a high score in a game.
Variables can be strings of text, numerical values, or any other type of data.
Using a variable as an identifier is a useful way to refer to program items that are unknown to you,
such as a username, a service, or a file name for instance.
If you don’t use a variable, then you will need to hard code
all the names and values in your program, which is not considered best practice.
Variables can be declared and assigned a data type and initial value as they are defined,
or you can decide not to assign an initial value when you define a variable,
and instead have the value assigned later by instructions within the program.
In addition to the identifier data structures already discussed,
there are also special kinds of identifiers that can reference multiple elements in a program,
and these are referred to as containers.
Being able to specify multiple elements means that you don’t have
to create a variable for every individual element.
This makes it faster and more efficient.
For example, if you only want to store six numerical integers,
then you could argue that you could just create six variables, one for each.
But what if you need to store 1,000 integers or more? In such a case,
defining 1,000 variables would obviously be an unwieldly and inefficient programming technique,
so in this case you would use a container.
There are two types of containers to specify multiple elements: arrays and vectors.
The simplest of these container types is an array.
In an array, a fixed number of elements of the same type are stored
in sequential order, starting from index zero.
When you declare an array,
you specify the data type of the values it contains,
such as an integer, or boolean, or a string,
and then the maximum number of elements it can contain.
The syntax for declaring an array is to specify the data type first,
then the name of the array, then the maximum size of the array in square braces.
In contrast to arrays that have a fixed size, vectors have a dynamic size,
and they will automatically resize themselves as you add
elements to them or remove elements from them.
For this reason, you may also see them referred to as dynamic arrays.
Because they are dynamic in nature, vectors take up more memory space than arrays,
and their elements also take a little longer to access than elements in an array,
as they are not stored in sequential memory locations.
The syntax for declaring a vector is to specify the container type of the vector first,
then specify the data type in angle brackets,
then the name of the array. Note that because it is a vector, you do not need to specify
a maximum number of values it can contain because the size is not fixed, it is dynamic.
In this video, you learned that:
Software developers use an identifier to reference a program component.
If an identifier stores data, then it can either be a constant or a variable.
A constant is a data item whose value does not change within the program.
A variable is not constant; it can change during the program’s execution.
In an array, a fixed number of elements of the same type are stored
in sequential order, starting from zero.
And vectors have a dynamic size,
and they automatically resize themselves as elements are added or removed.
​

##### Welcome to Introduction to Programming Concepts – Part Two.
After watching this video, you will be able to:
Describe the purpose and use of functions in programming,
and describe the purpose and use of objects in programming.
Next, let’s look at the fundamental concept of functions.
Functions are a consequence of the
modular programming software development methodology
that encourages the separation of a program into multiple modular components,
where each performs a specific task within a program.
So, a function is essentially a piece of structured, stand-alone, and reusable code
that will perform a single specific action.
This enables software developers to take a substantial,
complex program and divide it into smaller,
more manageable, and focused pieces.
Although some programming languages may refer
to them as something else,
such as subroutines, procedures, methods, or modules,
most modern programming languages refer to them as functions.
Functions take in data as an input, then process the data,
and then return the result as an output.
There are essentially two types of functions.
Standard library functions are the built-in functions provided by the programming language.
Common examples include the ‘If’, ‘Else’, ‘While ’ and ‘Print’ functions.
But programming languages also allow you to write your own functions.
And once you’ve written a function, you can use it over and over again.
The way that the blocks of code that make up a function are identified
is different across programming languages.
Some use braces, some use begin and end statements,
and others use indentations for example.
There are a few steps to using functions.
The first thing you need to do is define (or create) a function.
When you define a function, you provide a function keyword,
then give the function a unique name,
and you provide the statements that make up the body of the function.
Once a function has been defined, it then needs to be called (or invoked).
When you call a function,
the specified actions within the function are performed using any specified parameters.
While defining and calling functions are common to all programming languages,
some programming languages, such as C and C++ ,
also require you to declare a function.
Next, let’s look at the concept of objects.
Understanding what objects are is key to
understanding object-oriented programming.
Object-oriented programming (or OOP) is a
programming methodology that is focused on objects rather than functions,
which is what procedure-oriented programming is focused on.
The objects themselves will contain data in the form of properties (or attributes)
and code in the form of procedures (or methods).
The key distinction between the two methodologies is that
where procedural programming uses methods to operate on separate data structures,
OOP packages them both together, so an object operates on its own data structure.
Consider the real-world objects in your life
such as your car, bike, TV, or your washing machine,
and ask yourself the following two questions:
“What states can the object be in?” and
“What behaviors can the object perform?”
When you think about your answers to these questions,
you will find that the answers to these questions vary across the objects.
More complex objects will typically have more potential states
they can be in and will be able to perform more behaviors.
In programming, a software object is similar
to a real-world object, conceptually speaking,
in that they too consist of states (or properties) and behaviors (or methods).
Software objects can be anything, such as a Windows service, a user account,
a database table, or a system folder.
Objects store their properties in fields (referred to as variables in some programming languages),
and expose their behaviors through methods (referred to as functions in some programming languages).
In this video, you learned that:
• A function is a piece of structured, stand-alone, and reusable code that
will perform a single specific action.
• The defining and calling of functions is common to all programming languages.
• Object-oriented programming is a programming methodology
that is focused on objects rather than functions.
• Software objects consist of properties and methods.
​

#####  Hands-on Lab: Programming Fundamentals with Python
##### Practice Assignment

#### Summary and Quizzes
### Module 4 :
### Module 5 :
### Module 6 :
# Course 2
### Module 1 :
### Module 2 :
### Module 3 :
### Module 4 :
### Module 5 :
### Module 6 :
# Course 3
# Course 4
# Course 5
# Course 6
# Course 7
# Course 8
# Course 9
# Course 10
# Course 11
# Course 12
